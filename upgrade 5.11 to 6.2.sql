-- SHARED DB--
ALTER TABLE REG_LOG MODIFY REG_USER_ID varchar2(255);

ALTER TABLE REG_RESOURCE MODIFY REG_CREATOR varchar2(255);
ALTER TABLE REG_RESOURCE MODIFY REG_LAST_UPDATOR varchar2(255);

ALTER TABLE REG_RESOURCE_HISTORY MODIFY REG_CREATOR varchar2(255);
ALTER TABLE REG_RESOURCE_HISTORY MODIFY REG_LAST_UPDATOR varchar2(255);

ALTER TABLE REG_COMMENT MODIFY REG_USER_ID  varchar2(255);

ALTER TABLE REG_RESOURCE_COMMENT add ID INTEGER NOT NULL;
ALTER TABLE REG_RESOURCE_COMMENT ADD CONSTRAINT REG_RESOURCE_COMMENT_PK PRIMARY KEY (ID);

CREATE SEQUENCE REG_RESOURCE_COMMENT_SEQUENCE START WITH 1 INCREMENT BY 1 CACHE 20
/
CREATE OR REPLACE TRIGGER REG_RESOURCE_COMMENT_TRIGGER
BEFORE INSERT
ON REG_RESOURCE_COMMENT
REFERENCING NEW AS NEW
FOR EACH ROW
    BEGIN
        SELECT REG_RESOURCE_COMMENT_SEQUENCE.nextval INTO :NEW.ID FROM dual;
    END;
/
ALTER TABLE REG_RATING MODIFY REG_USER_ID  varchar2(255);
/
ALTER TABLE REG_RESOURCE_RATING add ID INTEGER NOT NULL;
ALTER TABLE REG_RESOURCE_RATING ADD CONSTRAINT REG_RESOURCE_RATING_PK PRIMARY KEY (ID);
/
CREATE SEQUENCE REG_RESOURCE_RATING_SEQUENCE START WITH 1 INCREMENT BY 1 CACHE 20
/
CREATE OR REPLACE TRIGGER REG_RESOURCE_RATING_TRIGGER
BEFORE INSERT
ON REG_RESOURCE_RATING
REFERENCING NEW AS NEW
FOR EACH ROW
    BEGIN
        SELECT REG_RESOURCE_RATING_SEQUENCE.nextval INTO :NEW.ID FROM dual;
    END;
/
ALTER TABLE REG_TAG MODIFY REG_USER_ID  varchar2(255);
/
ALTER TABLE REG_RESOURCE_TAG add ID INTEGER NOT NULL;
ALTER TABLE REG_RESOURCE_TAG ADD CONSTRAINT REG_RESOURCE_TAG_PK PRIMARY KEY (ID);
/
CREATE SEQUENCE REG_RESOURCE_TAG_SEQUENCE START WITH 1 INCREMENT BY 1 CACHE 20;
/
CREATE OR REPLACE TRIGGER REG_RESOURCE_TAG_TRIGGER
BEFORE INSERT
ON REG_RESOURCE_TAG
REFERENCING NEW AS NEW
FOR EACH ROW
    BEGIN
        SELECT REG_RESOURCE_TAG_SEQUENCE.nextval INTO :NEW.ID FROM dual;
    END;
/
ALTER TABLE REG_RESOURCE_PROPERTY add ID INTEGER;
CREATE SEQUENCE REG_RESOURCE_PROPERTY_SEQUENCE START WITH 1 INCREMENT BY 1 CACHE 20
/
CREATE OR REPLACE TRIGGER REG_RESOURCE_PROPERTY_TRIGGER
BEFORE INSERT
ON REG_RESOURCE_PROPERTY
REFERENCING NEW AS NEW
FOR EACH ROW
    BEGIN
        SELECT REG_RESOURCE_PROPERTY_SEQUENCE.nextval INTO :NEW.ID FROM dual;
    END;
/
UPDATE REG_RESOURCE_PROPERTY SET id = REG_RESOURCE_PROPERTY_SEQUENCE.NEXTVAL;
ALTER TABLE REG_RESOURCE_PROPERTY ADD CONSTRAINT REG_RESOURCE_PROPERTY_PK PRIMARY KEY (ID);
ALTER TABLE REG_RESOURCE_PROPERTY MODIFY ID NOT NULL;
/
ALTER TABLE UM_TENANT add UM_ORG_UUID VARCHAR(36) DEFAULT NULL;
/
ALTER TABLE UM_USER ADD CONSTRAINT U_UM_USER_NAME UNIQUE (UM_USER_NAME, UM_TENANT_ID);
/
select um_user_name, count(1)
from um_user
group by um_user_name
having count(1) > 1;
select * from um_user where um_user_name = 'admin2';
-- delete from um_user where um_id in (41305,41313,41309);
-- delete from um_user_attribute where um_user_id in (41305,41313,41309);
/
ALTER TABLE UM_SHARED_USER_ROLE add ID INTEGER NOT NULL;
ALTER TABLE UM_SHARED_USER_ROLE ADD CONSTRAINT pk_UM_SHARED_USER_ROLE PRIMARY KEY (id);
/
CREATE SEQUENCE UM_SHARED_USER_ROLE_SEQUENCE START WITH 1 INCREMENT BY 1 CACHE 20
/
CREATE OR REPLACE TRIGGER UM_SHARED_USER_ROLE_TRIGGER
BEFORE INSERT
ON UM_SHARED_USER_ROLE
REFERENCING NEW AS NEW
FOR EACH ROW
    BEGIN
        SELECT UM_SHARED_USER_ROLE_SEQUENCE.nextval INTO :NEW.ID FROM dual;
    END;
/

CREATE TABLE UM_GROUP_UUID_DOMAIN_MAPPER (
            UM_ID INTEGER,
            UM_GROUP_ID VARCHAR(255) NOT NULL,
            UM_DOMAIN_ID INTEGER NOT NULL,
            UM_TENANT_ID INTEGER DEFAULT 0,
            PRIMARY KEY (UM_ID),
            UNIQUE (UM_GROUP_ID),
            FOREIGN KEY (UM_DOMAIN_ID, UM_TENANT_ID) REFERENCES UM_DOMAIN(UM_DOMAIN_ID, UM_TENANT_ID) ON DELETE CASCADE
)
/

CREATE SEQUENCE UM_GROUP_UUID_DOMAIN_MAPPER_SEQUENCE START WITH 1 INCREMENT BY 1 NOCACHE

/
CREATE OR REPLACE TRIGGER UM_GROUP_UUID_DOMAIN_MAPPER_TRIGGER
                    BEFORE INSERT
                    ON UM_GROUP_UUID_DOMAIN_MAPPER
                    REFERENCING NEW AS NEW
                    FOR EACH ROW
                    BEGIN
                    SELECT UM_GROUP_UUID_DOMAIN_MAPPER_SEQUENCE.nextval INTO :NEW.UM_ID FROM dual;
              END;
/

CREATE INDEX UUID_GRP_UID_TID ON UM_GROUP_UUID_DOMAIN_MAPPER(UM_GROUP_ID, UM_TENANT_ID)
/

-- ################################
-- ORGANIZATION MANAGEMENT TABLES
-- ################################

CREATE TABLE UM_ORG (
            UM_ID VARCHAR(36) NOT NULL,
            UM_ORG_NAME VARCHAR(255) NOT NULL,
            UM_ORG_DESCRIPTION VARCHAR(1024),
            UM_CREATED_TIME TIMESTAMP NOT NULL,
            UM_LAST_MODIFIED TIMESTAMP NOT NULL,
            UM_STATUS VARCHAR(255) DEFAULT 'ACTIVE' NOT NULL,
            UM_PARENT_ID VARCHAR(36),
            UM_ORG_TYPE VARCHAR(100) NOT NULL,
            PRIMARY KEY (UM_ID),
            FOREIGN KEY (UM_PARENT_ID) REFERENCES UM_ORG(UM_ID) ON DELETE CASCADE
)
/
INSERT INTO UM_ORG (UM_ID, UM_ORG_NAME, UM_ORG_DESCRIPTION, UM_CREATED_TIME, UM_LAST_MODIFIED, UM_STATUS, UM_ORG_TYPE)
SELECT '10084a8d-113f-4211-a0d5-efe36b082211', 'Super', 'This is the super organization.', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 'ACTIVE', 'TENANT' FROM DUAL
WHERE NOT EXISTS (SELECT * FROM UM_ORG WHERE UM_ID = '10084a8d-113f-4211-a0d5-efe36b082211')
/
CREATE TABLE UM_ORG_ATTRIBUTE (
            UM_ID INTEGER,
            UM_ORG_ID VARCHAR(36) NOT NULL,
            UM_ATTRIBUTE_KEY VARCHAR(255) NOT NULL,
            UM_ATTRIBUTE_VALUE VARCHAR(512),
            PRIMARY KEY (UM_ID),
            UNIQUE (UM_ORG_ID, UM_ATTRIBUTE_KEY),
            FOREIGN KEY (UM_ORG_ID) REFERENCES UM_ORG(UM_ID) ON DELETE CASCADE
)
/
CREATE SEQUENCE UM_ORG_ATTRIBUTE_SEQ START WITH 1 INCREMENT BY 1 NOCACHE
/
CREATE OR REPLACE TRIGGER UM_ORG_ATTRIBUTE_TRIG
            BEFORE INSERT
            ON UM_ORG_ATTRIBUTE
            REFERENCING NEW AS NEW
            FOR EACH ROW
              BEGIN
                SELECT UM_ORG_ATTRIBUTE_SEQ.nextval INTO :NEW.UM_ID FROM dual;
              END;
/
CREATE TABLE UM_ORG_ROLE (
            UM_ROLE_ID VARCHAR(255) NOT NULL,
            UM_ROLE_NAME VARCHAR(255) NOT NULL,
            UM_ORG_ID VARCHAR(36) NOT NULL,
            PRIMARY KEY(UM_ROLE_ID),
            CONSTRAINT FK_UM_ORG_ROLE_UM_ORG FOREIGN KEY (UM_ORG_ID) REFERENCES UM_ORG (UM_ID) ON DELETE CASCADE
)
/
CREATE TABLE UM_ORG_PERMISSION(
            UM_ID INTEGER,
            UM_RESOURCE_ID VARCHAR(255) NOT NULL,
            UM_ACTION VARCHAR(255) NOT NULL,
            UM_TENANT_ID INTEGER DEFAULT 0,
            PRIMARY KEY (UM_ID)
)
/
CREATE SEQUENCE UM_ORG_PERMISSION_SEQ START WITH 1 INCREMENT BY 1 NOCACHE
/
CREATE OR REPLACE TRIGGER UM_ORG_PERMISSION_TRIG
            BEFORE INSERT
            ON UM_ORG_PERMISSION
            REFERENCING NEW AS NEW
            FOR EACH ROW
              BEGIN
                SELECT UM_ORG_PERMISSION_SEQ.nextval INTO :NEW.UM_ID FROM dual;
              END;
/
CREATE TABLE UM_ORG_ROLE_USER (
            UM_USER_ID VARCHAR(255) NOT NULL,
            UM_ROLE_ID VARCHAR(255) NOT NULL,
			UM_USER_RESIDENT_ORG_ID VARCHAR(36),
            CONSTRAINT FK_UM_ORG_ROLE_USER_UM_ORG_ROLE FOREIGN KEY (UM_ROLE_ID) REFERENCES UM_ORG_ROLE(UM_ROLE_ID) ON DELETE CASCADE
)
/
alter table UM_ORG_ROLE_USER add UM_USER_RESIDENT_ORG_ID VARCHAR(36);
/
CREATE TABLE UM_ORG_ROLE_GROUP(
            UM_GROUP_ID VARCHAR(255) NOT NULL,
            UM_ROLE_ID VARCHAR(255) NOT NULL,
            CONSTRAINT FK_UM_ORG_ROLE_GROUP_UM_ORG_ROLE FOREIGN KEY (UM_ROLE_ID) REFERENCES UM_ORG_ROLE(UM_ROLE_ID) ON DELETE CASCADE
)
/
CREATE TABLE UM_ORG_ROLE_PERMISSION(
            UM_PERMISSION_ID INTEGER NOT NULL,
            UM_ROLE_ID VARCHAR(255) NOT NULL,
            CONSTRAINT FK_UM_ORG_ROLE_PERMISSION_UM_ORG_ROLE FOREIGN KEY (UM_ROLE_ID) REFERENCES UM_ORG_ROLE(UM_ROLE_ID) ON DELETE CASCADE,
            CONSTRAINT FK_UM_ORG_ROLE_PERMISSION_UM_ORG_PERMISSION FOREIGN KEY (UM_PERMISSION_ID) REFERENCES UM_ORG_PERMISSION(UM_ID) ON DELETE CASCADE
)
/
CREATE TABLE UM_ORG_HIERARCHY (
            UM_PARENT_ID VARCHAR(36) NOT NULL,
            UM_ID VARCHAR(36) NOT NULL,
            DEPTH INTEGER,
            PRIMARY KEY (UM_PARENT_ID, UM_ID),
            FOREIGN KEY (UM_PARENT_ID) REFERENCES UM_ORG(UM_ID) ON DELETE CASCADE,
            FOREIGN KEY (UM_ID) REFERENCES UM_ORG(UM_ID) ON DELETE CASCADE
)
/
INSERT INTO UM_ORG_HIERARCHY (UM_PARENT_ID, UM_ID, DEPTH)
SELECT '10084a8d-113f-4211-a0d5-efe36b082211', '10084a8d-113f-4211-a0d5-efe36b082211', 0 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM UM_ORG_HIERARCHY WHERE UM_PARENT_ID = '10084a8d-113f-4211-a0d5-efe36b082211' AND UM_ID = '10084a8d-113f-4211-a0d5-efe36b082211')
/

-- 6.1 to 6.2
alter table UM_ORG_ROLE_USER add UM_USER_RESIDENT_ORG_ID VARCHAR(36);
CREATE INDEX REG_RESC_PROP_BY_PROP_ID_TI ON REG_RESOURCE_PROPERTY(REG_TENANT_ID,REG_PROPERTY_ID);
CREATE INDEX INDEX_UM_TENANT_ORG_UUID ON UM_TENANT(UM_ORG_UUID);
CREATE INDEX INDEX_ROLE_PERMSN_TI_RN ON UM_ROLE_PERMISSION(UM_TENANT_ID,UM_ROLE_NAME);


-- COMMEMT --
ALTER TABLE CM_SP_PURPOSE_PURPOSE_CAT_ASSC ADD ID INTEGER NOT NULL;
ALTER TABLE CM_SP_PURPOSE_PURPOSE_CAT_ASSC ADD CONSTRAINT pk_CM_SP_PURPOSE_PURPOSE_CAT_ASSC PRIMARY KEY (ID);
/
CREATE SEQUENCE CM_SP_PURPOSE_PPS_CT_ASSC_SEQ START WITH 1 INCREMENT BY 1 CACHE 20 ORDER
/
CREATE OR REPLACE TRIGGER CM_SP_PURPOSE_PPS_CT_ASSC_TRIG
  BEFORE INSERT
  ON CM_SP_PURPOSE_PURPOSE_CAT_ASSC
  REFERENCING NEW AS NEW
  FOR EACH ROW
  BEGIN
    SELECT CM_SP_PURPOSE_PPS_CT_ASSC_SEQ.nextval INTO :NEW.ID FROM dual;
  END;
/
ALTER TABLE CM_PURPOSE_PII_CAT_ASSOC ADD ID INTEGER NOT NULL;
ALTER TABLE CM_PURPOSE_PII_CAT_ASSOC ADD CONSTRAINT pk_CM_PURPOSE_PII_CAT_ASSOC PRIMARY KEY (ID);
/
CREATE SEQUENCE CM_PURPOSE_PII_CAT_ASSOC_SEQ START WITH 1 INCREMENT BY 1 CACHE 20 ORDER
/
CREATE OR REPLACE TRIGGER CM_PURPOSE_PII_CAT_ASSOC_TRIG
  BEFORE INSERT
  ON CM_PURPOSE_PII_CAT_ASSOC
  REFERENCING NEW AS NEW
  FOR EACH ROW
  BEGIN
    SELECT CM_PURPOSE_PII_CAT_ASSOC_SEQ.nextval INTO :NEW.ID FROM dual;
  END;
/
ALTER TABLE CM_SP_PURPOSE_PII_CAT_ASSOC ADD ID INTEGER NOT NULL;
ALTER TABLE CM_SP_PURPOSE_PII_CAT_ASSOC ADD IS_CONSENTED NUMBER(1) DEFAULT 1;
ALTER TABLE CM_SP_PURPOSE_PII_CAT_ASSOC ADD CONSTRAINT pk_CM_SP_PURPOSE_PII_CAT_ASSOC PRIMARY KEY (ID);
/
CREATE SEQUENCE CM_SP_PURPOSE_PII_CT_ASSC_SEQ START WITH 1 INCREMENT BY 1 CACHE 20 ORDER
/
CREATE OR REPLACE TRIGGER CM_SP_PURPOSE_PII_CT_ASSC_TRIG
  BEFORE INSERT
  ON CM_SP_PURPOSE_PII_CAT_ASSOC
  REFERENCING NEW AS NEW
  FOR EACH ROW
  BEGIN
    SELECT CM_SP_PURPOSE_PII_CT_ASSC_SEQ.nextval INTO :NEW.ID FROM dual;
  END;
/
ALTER TABLE CM_CONSENT_RECEIPT_PROPERTY ADD ID INTEGER NOT NULL;
ALTER TABLE CM_CONSENT_RECEIPT_PROPERTY ADD CONSTRAINT pk_CM_CONSENT_RECEIPT_PROPERTY PRIMARY KEY (ID);
/
CREATE SEQUENCE CM_CONSENT_RECEIPT_SEQ START WITH 1 INCREMENT BY 1 CACHE 20 ORDER
/
CREATE OR REPLACE TRIGGER CM_CONSENT_RECEIPT_TRIG
  BEFORE INSERT
  ON CM_CONSENT_RECEIPT_PROPERTY
  REFERENCING NEW AS NEW
  FOR EACH ROW
  BEGIN
    SELECT CM_CONSENT_RECEIPT_SEQ.nextval INTO :NEW.ID FROM dual;
  END;
/




-------------------- IDENTTIY DB----------------------
ALTER TABLE IDN_OAUTH2_ACCESS_TOKEN ADD CONSENTED_TOKEN VARCHAR(6);
/
DROP TABLE IDN_OAUTH2_TOKEN_BINDING;
CREATE TABLE IDN_OAUTH2_TOKEN_BINDING (
            TOKEN_ID VARCHAR2 (255),
            TOKEN_BINDING_TYPE VARCHAR2 (32),
            TOKEN_BINDING_REF VARCHAR2 (32),
            TOKEN_BINDING_VALUE VARCHAR2 (1024),
            TENANT_ID INTEGER DEFAULT -1,
            UNIQUE (TOKEN_ID,TOKEN_BINDING_TYPE,TOKEN_BINDING_VALUE),
            FOREIGN KEY (TOKEN_ID) REFERENCES IDN_OAUTH2_ACCESS_TOKEN(TOKEN_ID) ON DELETE CASCADE);
/
truncate table IDN_OAUTH2_ACCESS_TOKEN_AUDIT;
ALTER TABLE IDN_OAUTH2_ACCESS_TOKEN_AUDIT ADD ID INTEGER NOT NULL;
ALTER TABLE IDN_OAUTH2_ACCESS_TOKEN_AUDIT ADD CONSTRAINT pk_IDN_OAUTH2_ACCESS_TOKEN_AUDIT PRIMARY KEY (ID);
/
CREATE SEQUENCE IDN_OAUTH2_ACCESS_TKN_ADT_SEQ START WITH 1 INCREMENT BY 1 CACHE 20 ORDER
/
CREATE OR REPLACE TRIGGER IDN_OAUTH2_ACCESS_TKN_ADT_TRIG
BEFORE INSERT
ON IDN_OAUTH2_ACCESS_TOKEN_AUDIT
REFERENCING NEW AS NEW
FOR EACH ROW
    BEGIN
        SELECT IDN_OAUTH2_ACCESS_TKN_ADT_SEQ.nextval INTO :NEW.ID FROM dual;
    END;
/
ALTER TABLE IDN_OAUTH2_DEVICE_FLOW ADD QUANTIFIER INTEGER DEFAULT 0 NOT NULL;
/
ALTER TABLE IDN_OAUTH2_SCOPE_BINDING ADD ID INTEGER;
/
CREATE SEQUENCE IDN_OAUTH2_SCOPE_BINDING_SEQ START WITH 1 INCREMENT BY 1 CACHE 20 ORDER
/
CREATE OR REPLACE TRIGGER IDN_OAUTH2_SCOPE_BINDING_TRIG
BEFORE INSERT
ON IDN_OAUTH2_SCOPE_BINDING
REFERENCING NEW AS NEW
FOR EACH ROW
    BEGIN
        SELECT IDN_OAUTH2_SCOPE_BINDING_SEQ.nextval INTO :NEW.ID FROM dual;
    END;
/
UPDATE IDN_OAUTH2_SCOPE_BINDING SET id = IDN_OAUTH2_SCOPE_BINDING_SEQ.NEXTVAL;
/
ALTER TABLE IDN_OAUTH2_SCOPE_BINDING ADD CONSTRAINT pk_IDN_OAUTH2_SCOPE_BINDING PRIMARY KEY (ID);    
ALTER TABLE IDN_OAUTH2_SCOPE_BINDING MODIFY ID INTEGER NOT NULL;
/
ALTER TABLE IDN_SCIM_GROUP ADD CONSTRAINT U_IDN_SCIM_GROUP UNIQUE (TENANT_ID, ROLE_NAME, ATTR_NAME);
/
ALTER TABLE IDN_AUTH_USER_SESSION_MAPPING ADD ID INTEGER;
/
CREATE SEQUENCE IDN_AUTH_USER_SESSION_MAP_SEQ START WITH 1 INCREMENT BY 1 CACHE 20 ORDER
/
CREATE OR REPLACE TRIGGER IDN_AUTH_USER_SESSION_MAP_TRIG
BEFORE INSERT
ON IDN_AUTH_USER_SESSION_MAPPING
REFERENCING NEW AS NEW
FOR EACH ROW
    BEGIN
        SELECT IDN_AUTH_USER_SESSION_MAP_SEQ.nextval INTO :NEW.ID FROM dual;
    END;
/
UPDATE IDN_AUTH_USER_SESSION_MAPPING SET id = IDN_AUTH_USER_SESSION_MAP_SEQ.NEXTVAL;
/
ALTER TABLE IDN_AUTH_USER_SESSION_MAPPING ADD CONSTRAINT pk_IDN_AUTH_USER_SESSION_MAPPING PRIMARY KEY (ID);    
ALTER TABLE IDN_AUTH_USER_SESSION_MAPPING MODIFY ID INTEGER NOT NULL;
/
ALTER TABLE WF_BPS_PROFILE MODIFY USERNAME VARCHAR2(100);
/
ALTER TABLE IDN_OAUTH2_CIBA_REQUEST_SCOPES ADD ID INTEGER NOT NULL;
ALTER TABLE IDN_OAUTH2_CIBA_REQUEST_SCOPES ADD CONSTRAINT pk_IDN_OAUTH2_CIBA_REQUEST_SCOPES PRIMARY KEY (ID);  
CREATE SEQUENCE IDN_OAUTH2_CIBA_SCOPES_SEQ START WITH 1 INCREMENT BY 1 CACHE 20 ORDER
/
CREATE OR REPLACE TRIGGER IDN_OAUTH2_CIBA_SCOPES_TRIG
    BEFORE INSERT
    ON IDN_OAUTH2_CIBA_REQUEST_SCOPES
    REFERENCING NEW AS NEW
    FOR EACH ROW
        BEGIN
            SELECT IDN_OAUTH2_CIBA_SCOPES_SEQ.nextval INTO :NEW.ID FROM dual;
        END;
/
DROP TABLE IDN_FED_AUTH_SESSION_MAPPING;
/
CREATE TABLE IDN_FED_AUTH_SESSION_MAPPING (
    ID INTEGER,
	IDP_SESSION_ID VARCHAR(255) NOT NULL,
	SESSION_ID VARCHAR(255) NOT NULL,
	IDP_NAME VARCHAR(255) NOT NULL,
	AUTHENTICATOR_ID VARCHAR(255),
	PROTOCOL_TYPE VARCHAR(255),
	TIME_CREATED TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
	TENANT_ID INTEGER DEFAULT 0,
	PRIMARY KEY (ID),
	UNIQUE (IDP_SESSION_ID, TENANT_ID)
)
/

CREATE SEQUENCE IDN_FED_AUTH_SESSION_MAPPING_SEQ START WITH 1 INCREMENT BY 1 NOCACHE
/
CREATE OR REPLACE TRIGGER IDN_FED_AUTH_SESSION_MAPPING_TRIG
            BEFORE INSERT
            ON IDN_FED_AUTH_SESSION_MAPPING
            REFERENCING NEW AS NEW
            FOR EACH ROW
                BEGIN
                    SELECT IDN_FED_AUTH_SESSION_MAPPING_SEQ.nextval INTO :NEW.ID FROM dual;
                END;
/
INSERT INTO IDN_CONFIG_TYPE (ID, NAME, DESCRIPTION) VALUES ('669b99ca-cdb0-44a6-8cae-babed3b585df', 'Publisher', 'A resource type to keep the event publisher configurations');
INSERT INTO IDN_CONFIG_TYPE (ID, NAME, DESCRIPTION) VALUES ('73f6d9ca-62f4-4566-bab9-2a930ae51ba8', 'BRANDING_PREFERENCES', 'A resource type to keep the tenant branding preferences');
INSERT INTO IDN_CONFIG_TYPE (ID, NAME, DESCRIPTION) VALUES ('899c69b2-8bf7-46b5-9666-f7f99f90d6cc', 'fido-config', 'A resource type to store FIDO authenticator related preferences');
INSERT INTO IDN_CONFIG_TYPE (ID, NAME, DESCRIPTION) VALUES ('7f24050f-3e3d-4a00-b10f-fd5450d6523e', 'input-validation-configurations', 'A resource type to store input validation related configurations');
/
CREATE TABLE IDN_OAUTH2_USER_CONSENT (
    ID INTEGER NOT NULL,
    USER_ID VARCHAR(255) NOT NULL,
    APP_ID CHAR(36) NOT NULL,
    TENANT_ID INTEGER DEFAULT -1 NOT NULL,
    CONSENT_ID VARCHAR(255) NOT NULL,

    PRIMARY KEY (ID),
    FOREIGN KEY (APP_ID) REFERENCES SP_APP (UUID) ON DELETE CASCADE,
    UNIQUE (USER_ID, APP_ID, TENANT_ID),
    UNIQUE (CONSENT_ID)
)
/
CREATE SEQUENCE IDN_OAUTH2_USER_CONSENT_SEQUENCE START WITH 1 INCREMENT BY 1 CACHE 20
/
CREATE OR REPLACE TRIGGER IDN_OAUTH2_USER_CONSENT_TRIGGER
    BEFORE INSERT
        ON IDN_OAUTH2_USER_CONSENT
        REFERENCING NEW AS NEW
            FOR EACH ROW
                BEGIN
                    SELECT IDN_OAUTH2_USER_CONSENT_SEQUENCE.nextval INTO :NEW.ID FROM dual;
                END;
/

CREATE TABLE IDN_OAUTH2_USER_CONSENTED_SCOPES (
    ID INTEGER NOT NULL,
    CONSENT_ID VARCHAR(255) NOT NULL,
    TENANT_ID INTEGER DEFAULT -1 NOT NULL,
    SCOPE VARCHAR(255) NOT NULL,
    CONSENT NUMBER(1,0) DEFAULT 1 NOT NULL,

    PRIMARY KEY (ID),
    FOREIGN KEY (CONSENT_ID) REFERENCES IDN_OAUTH2_USER_CONSENT (CONSENT_ID) ON DELETE CASCADE,
    UNIQUE (CONSENT_ID, SCOPE)
)
/
CREATE SEQUENCE IDN_OAUTH2_USER_CONSENTED_SCOPES_SEQUENCE START WITH 1 INCREMENT BY 1 CACHE 20
/
CREATE OR REPLACE TRIGGER IDN_OAUTH2_USER_CONSENTED_SCOPES_TRIGGER
    BEFORE INSERT
        ON IDN_OAUTH2_USER_CONSENTED_SCOPES
        REFERENCING NEW AS NEW
            FOR EACH ROW
                BEGIN
                    SELECT IDN_OAUTH2_USER_CONSENTED_SCOPES_SEQUENCE.nextval INTO :NEW.ID FROM dual;
                END;
/

CREATE TABLE IDN_SECRET_TYPE (
    ID VARCHAR2(255) NOT NULL,
    NAME VARCHAR2(255) NOT NULL,
    DESCRIPTION VARCHAR2(1023) NULL,
    PRIMARY KEY (ID),
    CONSTRAINT SECRET_TYPE_NAME_CONSTRAINT UNIQUE (NAME)
)
/

INSERT INTO IDN_SECRET_TYPE (ID, NAME, DESCRIPTION) VALUES
('1358bdbf-e0cc-4268-a42c-c3e0960e13f0', 'ADAPTIVE_AUTH_CALL_CHOREO', 'Secret type to uniquely identify secrets relevant to callChoreo adaptive auth function')
/

CREATE TABLE IDN_SECRET (
    ID VARCHAR2(255) NOT NULL,
    TENANT_ID NUMBER(22,0) NOT NULL,
    SECRET_NAME VARCHAR2(255) NOT NULL,
    SECRET_VALUE VARCHAR(4000) NOT NULL,
    CREATED_TIME TIMESTAMP NOT NULL,
    LAST_MODIFIED TIMESTAMP NOT NULL,
    TYPE_ID VARCHAR2(255) NOT NULL,
    DESCRIPTION VARCHAR2(1023) NULL,
    PRIMARY KEY (ID),
    FOREIGN KEY (TYPE_ID) REFERENCES IDN_SECRET_TYPE(ID) ON DELETE CASCADE,
    UNIQUE (SECRET_NAME, TENANT_ID, TYPE_ID)
)
/

CREATE TABLE SP_SHARED_APP (
    ID INTEGER,
    MAIN_APP_ID CHAR(36) NOT NULL,
    OWNER_ORG_ID CHAR(36) NOT NULL,
    SHARED_APP_ID CHAR(36) NOT NULL,
    SHARED_ORG_ID CHAR(36) NOT NULL,
    SHARE_WITH_ALL_CHILDREN NUMBER(1,0) DEFAULT 0,
    PRIMARY KEY (ID),
    FOREIGN KEY (MAIN_APP_ID) REFERENCES SP_APP(UUID) ON DELETE CASCADE,
    FOREIGN KEY (SHARED_APP_ID) REFERENCES SP_APP(UUID) ON DELETE CASCADE,
    UNIQUE (MAIN_APP_ID, OWNER_ORG_ID, SHARED_ORG_ID),
    UNIQUE (SHARED_APP_ID)
)
/
CREATE SEQUENCE SP_SHARED_APP_SEQ START WITH 1 INCREMENT BY 1 NOCACHE
/
CREATE OR REPLACE TRIGGER SP_SHARED_APP_TRIG
            BEFORE INSERT
            ON SP_SHARED_APP
            REFERENCING NEW AS NEW
            FOR EACH ROW
              BEGIN
                SELECT SP_SHARED_APP_SEQ.nextval INTO :NEW.ID FROM dual;
              END;
/
drop index IDX_AT_CK_AU;
drop index IDX_AT_AU_TID_UD_TS_CKID;
drop index IDX_AT_AU_CKID_TS_UT;
/
drop index IDX_IDN_SCIM_GROUP_TI_RN_AN;
/
CREATE INDEX IDX_IDN_AUTH_SSTR_ST_OP_ID_TM ON IDN_AUTH_SESSION_STORE (OPERATION, SESSION_TYPE, SESSION_ID, TIME_CREATED)
/
CREATE INDEX IDX_IDN_AUTH_SSTR_ET_ID ON IDN_AUTH_SESSION_STORE (EXPIRY_TIME, SESSION_ID)
/
DROP INDEX IDX_IOP_TID_CK;
CREATE INDEX IDX_IOP_CK ON IDN_OIDC_PROPERTY(CONSUMER_KEY);
CREATE INDEX IDX_TK_VALUE_TYPE ON IDN_OAUTH2_TOKEN_BINDING (TOKEN_BINDING_VALUE, TOKEN_BINDING_TYPE);
CREATE INDEX IDX_SP_APP_NAME_CI ON SP_APP (LOWER(APP_NAME));

-- 6.1 to 6.2
alter table IDN_OAUTH2_ACCESS_TOKEN_SCOPE MODIFY TOKEN_SCOPE VARCHAR(255);

CREATE TABLE IDP_GROUP (
			ID INTEGER NOT NULL,
			IDP_ID INTEGER NOT NULL,
			TENANT_ID INTEGER NOT NULL,
			GROUP_NAME VARCHAR(255) NOT NULL,
			UUID CHAR(36) NOT NULL,
			PRIMARY KEY (ID),
			UNIQUE (IDP_ID, GROUP_NAME),
			UNIQUE (UUID),
			FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE)
/
CREATE SEQUENCE IDP_GROUP_SEQ START WITH 1 INCREMENT BY 1 CACHE 20
/
CREATE OR REPLACE TRIGGER IDP_GROUP_TRIG
            BEFORE INSERT
            ON IDP_GROUP
            REFERENCING NEW AS NEW
            FOR EACH ROW
               BEGIN
                   SELECT IDP_GROUP_SEQ.nextval INTO :NEW.ID FROM dual;
               END;
/
drop table IDN_OIDC_JTI;
CREATE TABLE IDN_OIDC_JTI (
  JWT_ID VARCHAR(255) NOT NULL,
  TENANT_ID INTEGER NOT NULL,
  EXP_TIME TIMESTAMP NOT NULL,
  TIME_CREATED TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  PRIMARY KEY (JWT_ID,TENANT_ID));
/
drop table IDN_FED_AUTH_SESSION_MAPPING;
CREATE TABLE IDN_FED_AUTH_SESSION_MAPPING (
	ID INTEGER,
	IDP_SESSION_ID VARCHAR(255) NOT NULL,
	SESSION_ID VARCHAR(255) NOT NULL,
	IDP_NAME VARCHAR(255) NOT NULL,
	AUTHENTICATOR_ID VARCHAR(255),
	PROTOCOL_TYPE VARCHAR(255),
	TIME_CREATED TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
	TENANT_ID INTEGER DEFAULT 0,
	IDP_ID INTEGER DEFAULT 0,
	FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE,
	PRIMARY KEY (ID),
	UNIQUE (IDP_SESSION_ID, TENANT_ID, IDP_ID)
);
/
INSERT INTO IDN_CONFIG_TYPE (ID, NAME, DESCRIPTION) VALUES  ('f4e83b8a-d1c4-a0d6-03a7-d48e268c60c5', 'PK_JWT_CONFIGURATION', 'A resource type to keep the tenant private key jwt configuration.');
INSERT INTO IDN_CONFIG_TYPE (ID, NAME, DESCRIPTION) VALUES  ('9ec61e9d-f0e6-4952-9a09-ab842aeb2db2', 'ATTRIBUTE_CONFIGURATION', 'A resource type to store attribute related configurations.');
/
INSERT INTO IDN_SECRET_TYPE (ID, NAME, DESCRIPTION) VALUES ('c508ca28-60c0-4493-a758-77e4173ffdb9', 'IDP_SECRET_PROPERTIES', 'Secret type to uniquely identify secrets relevant to identity providers');
INSERT INTO IDN_SECRET_TYPE (ID, NAME, DESCRIPTION) VALUES ('433df096-62b7-4a36-b3eb-1bed9150ed35', 'IDVP_SECRET_PROPERTIES', 'Secret type to uniquely identify secrets relevant to identity verification providers');
/
alter table IDN_SECRET modify SECRET_NAME VARCHAR2(1023);
alter table IDN_SECRET add KEY_ID VARCHAR(255) NULL;
/
CREATE TABLE IDVP (
    ID          INTEGER NOT NULL,
    UUID        CHAR(36) NOT NULL,
    TENANT_ID   INTEGER,
    IDVP_TYPE   VARCHAR(254),
    NAME        VARCHAR(254),
    DESCRIPTION VARCHAR(254),
    IS_ENABLED  CHAR(1) DEFAULT '1',
    PRIMARY KEY (ID),
    UNIQUE (TENANT_ID, NAME),
    UNIQUE (UUID)
)
/
CREATE SEQUENCE IDVP_SEQ START WITH 1 INCREMENT BY 1 CACHE 20
/
CREATE OR REPLACE TRIGGER IDVP_TRIG
            BEFORE INSERT
            ON IDVP
            REFERENCING NEW AS NEW
            FOR EACH ROW
            BEGIN
                SELECT IDVP_SEQ.nextval INTO :NEW.ID FROM dual;
            END;
/
CREATE TABLE IDVP_CLAIM_MAPPING (
  ID            INTEGER NOT NULL,
  IDVP_ID       INTEGER,
  TENANT_ID     INTEGER,
  CLAIM         VARCHAR(254),
  LOCAL_CLAIM   VARCHAR(254),
  PRIMARY KEY (ID),
  UNIQUE (IDVP_ID, CLAIM),
  FOREIGN KEY (IDVP_ID) REFERENCES IDVP(ID) ON DELETE CASCADE
)
/
CREATE SEQUENCE IDVP_CLAIM_MAPPING_SEQ START WITH 1 INCREMENT BY 1 CACHE 20
/
CREATE OR REPLACE TRIGGER IDVP_CLAIM_MAPPING_TRIG
            BEFORE INSERT
            ON IDVP_CLAIM_MAPPING
            REFERENCING NEW AS NEW
            FOR EACH ROW
            BEGIN
                SELECT IDVP_CLAIM_MAPPING_SEQ.nextval INTO :NEW.ID FROM dual;
            END;
/
CREATE TABLE IDVP_CONFIG (
    ID              INTEGER NOT NULL,
    IDVP_ID         INTEGER,
    TENANT_ID       INTEGER,
    PROPERTY_KEY    VARCHAR(254) NOT NULL,
    PROPERTY_VALUE  VARCHAR(1024),
    IS_SECRET CHAR(1) DEFAULT '0',
    PRIMARY KEY (ID),
    UNIQUE (IDVP_ID, PROPERTY_KEY, TENANT_ID),
    FOREIGN KEY (IDVP_ID) REFERENCES IDVP(ID) ON DELETE CASCADE
)
/
CREATE SEQUENCE IDVP_CONFIG_SEQ START WITH 1 INCREMENT BY 1 CACHE 20
/
CREATE OR REPLACE TRIGGER IDVP_CONFIG_TRIG
            BEFORE INSERT
            ON IDVP_CONFIG
            REFERENCING NEW AS NEW
            FOR EACH ROW
            BEGIN
                SELECT IDVP_CONFIG_SEQ.nextval INTO :NEW.ID FROM dual;
            END;
/
CREATE TABLE IDV_CLAIM (
    ID          INTEGER NOT NULL,
    UUID        CHAR(36) NOT NULL,
    USER_ID     VARCHAR(254) NOT NULL,
    CLAIM_URI   VARCHAR(254),
    IDVP_ID     CHAR(36) NOT NULL,
    TENANT_ID   INTEGER,
    IS_VERIFIED CHAR(1) DEFAULT '0',
    METADATA    BLOB,
    PRIMARY KEY (ID),
    UNIQUE (CLAIM_URI, TENANT_ID, USER_ID, IDVP_ID),
    UNIQUE (UUID),
    FOREIGN KEY (IDVP_ID) REFERENCES IDVP(UUID) ON DELETE CASCADE
)
/
CREATE SEQUENCE IDV_CLAIM_SEQ START WITH 1 INCREMENT BY 1 CACHE 20
/
CREATE OR REPLACE TRIGGER IDV_CLAIM_TRIG
            BEFORE INSERT
            ON IDV_CLAIM
            REFERENCING NEW AS NEW
            FOR EACH ROW
            BEGIN
                SELECT IDV_CLAIM_SEQ.nextval INTO :NEW.ID FROM dual;
            END;
/

CREATE TABLE IDN_OAUTH_PAR (
    REQ_URI_REF VARCHAR2(255) PRIMARY KEY,
    CLIENT_ID VARCHAR2(255),
    SCHEDULED_EXPIRY NUMBER(22,0),
    PARAMETERS CLOB
)
/
CREATE INDEX IDX_TBR_TS ON IDN_OAUTH2_ACCESS_TOKEN(TOKEN_BINDING_REF, TOKEN_STATE);

-- IDN_SECRET --
CREATE INDEX IDN_SECRET_TYPE_ID ON IDN_SECRET (TYPE_ID)
/

-- IDN_CLAIM --
CREATE INDEX IDX_CLAIM_TI_CU ON IDN_CLAIM (TENANT_ID, CLAIM_URI)
/

-- IDP_AUTHENTICATOR_PROPERTY --
CREATE INDEX IDX_AUTH_PROP_AUTH_ID ON IDP_AUTHENTICATOR_PROPERTY (AUTHENTICATOR_ID)
/

-- IDN_CONFIG_FILE --
CREATE INDEX IDX_CON_FILE_RES_ID ON IDN_CONFIG_FILE (RESOURCE_ID)
/

CREATE OR REPLACE PROCEDURE WSO2_CONFIRMATION_CODE_CLEANUP IS
    -- ------------------------------------------
    -- DECLARE VARIABLES
    -- ------------------------------------------
    systime TIMESTAMP := systimestamp;
    utcTime TIMESTAMP := sys_extract_utc(systimestamp);
    batchCount INT := 1000;
    chunkCount INT := 1000;
    rowCount INT   := 0;
    current_schema VARCHAR(20);
    cleanUpCodesTimeLimit TIMESTAMP;

    -- ------------------------------------------
    -- CONFIGURABLE VARIABLES
    -- ------------------------------------------
    batchSize INT        := 10000; -- SET BATCH SIZE FOR AVOID TABLE LOCKS [DEFAULT : 10000]
    chunkSize INT        := 500000; -- CHUNK WISE DELETE FOR LARGE TABLES [DEFAULT : 500000]
    enableLog BOOLEAN    := FALSE; -- ENABLE LOGGING [DEFAULT : FALSE]
    backupTables BOOLEAN := FALSE; -- SET IF TOKEN TABLE NEEDS TO BACKUP BEFORE DELETE [DEFAULT : FALSE], WILL DROP THE PREVIOUS BACKUP TABLES IN NEXT ITERATION
    cleanUpCodesTimeLimitInHrs INT := 720; -- SET SAFE PERIOD OF HOURS FOR CODE DELETE [DEFAULT : 720 hrs (30 days)]. CODES OLDER THAN THE NUMBER OF HOURS DEFINED HERE WILL BE DELETED.

BEGIN

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO current_schema FROM DUAL;
    cleanUpCodesTimeLimit := utcTime - cleanUpCodesTimeLimitInHrs/24;

    IF ( enableLog ) THEN
        SELECT COUNT(*) INTO rowCount FROM all_tables WHERE owner = current_schema AND table_name = UPPER('LOG_WSO2_CONFIRMATION_CODE_CLEANUP');
        IF ( rowcount = 1 ) THEN
            EXECUTE IMMEDIATE 'DROP TABLE LOG_WSO2_CONFIRMATION_CODE_CLEANUP';
            COMMIT;
        END IF;
        EXECUTE IMMEDIATE 'CREATE TABLE LOG_WSO2_CONFIRMATION_CODE_CLEANUP (TIMESTAMP VARCHAR(250) , LOG VARCHAR(250)) NOLOGGING';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_CONFIRMATION_CODE_CLEANUP (TIMESTAMP,LOG) VALUES (TO_CHAR(SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''LOG_WSO2_CONFIRMATION_CODE_CLEANUP STARTED .... !'')';
        COMMIT;
    END IF;

    -- ------------------------------------------
    -- BACKUP TABLES
    -- ------------------------------------------
    IF (backupTables)
    THEN

        SELECT COUNT(*) INTO rowCount FROM ALL_TABLES WHERE OWNER = current_schema AND table_name = 'BAK_IDN_RECOVERY_DATA';
        IF (rowCount = 1)
        THEN
            IF (enableLog)
            THEN
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_CONFIRMATION_CODE_CLEANUP (TIMESTAMP,LOG) VALUES (TO_CHAR(SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DELETING OLD BACKUP...'')';
            END IF;
            EXECUTE IMMEDIATE 'DROP TABLE BAK_IDN_RECOVERY_DATA';
            COMMIT;
        END if;

        EXECUTE IMMEDIATE 'CREATE TABLE BAK_IDN_RECOVERY_DATA AS (SELECT * FROM IDN_RECOVERY_DATA)';
        rowCount:= sql%rowcount;
        COMMIT;
    END IF;

    -- ------------------------------------------
    -- CLEANUP DATA
    -- ------------------------------------------
    WHILE (chunkCount > 0) LOOP
        -- CREATE CHUNK TABLE
        SELECT COUNT(*) INTO rowCount FROM ALL_TABLES WHERE OWNER = current_schema AND table_name = 'IDN_RECOVERY_DATA_CHUNK_TMP';
        IF (rowCount = 1)
        THEN
            EXECUTE IMMEDIATE 'DROP TABLE IDN_RECOVERY_DATA_CHUNK_TMP';
        END IF;
        EXECUTE IMMEDIATE 'CREATE TABLE IDN_RECOVERY_DATA_CHUNK_TMP AS (SELECT CODE FROM IDN_RECOVERY_DATA WHERE ROWNUM <= '||chunkSize||')';
        chunkCount:= sql%rowcount;
        COMMIT;
        IF (enableLog)
        THEN
            EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_CONFIRMATION_CODE_CLEANUP (TIMESTAMP,LOG) VALUES (TO_CHAR(SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CREATED IDN_RECOVERY_DATA_CHUNK_TMP...'')';
        END IF;

        -- BATCH LOOP
        batchCount := 1;
        WHILE (batchCount > 0) LOOP
            -- CREATE BATCH TABLE
            SELECT COUNT(*) INTO rowCount FROM ALL_TABLES WHERE OWNER = current_schema AND table_name = 'IDN_RECOVERY_DATA_BATCH_TMP';
            IF (rowCount = 1)
            THEN
                EXECUTE IMMEDIATE 'DROP TABLE IDN_RECOVERY_DATA_BATCH_TMP';
            END IF;
            EXECUTE IMMEDIATE 'CREATE TABLE IDN_RECOVERY_DATA_BATCH_TMP AS (SELECT * FROM IDN_RECOVERY_DATA_CHUNK_TMP WHERE ROWNUM <= '||batchSize||')';
            batchCount:= sql%rowcount;
            COMMIT;
            IF (enableLog)
            THEN
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_CONFIRMATION_CODE_CLEANUP (TIMESTAMP,LOG) VALUES (TO_CHAR(SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CREATED IDN_RECOVERY_DATA_BATCH_TMP...'')';
            END IF;

            -- BATCH DELETION
            IF (enableLog)
            THEN
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_CONFIRMATION_CODE_CLEANUP (TIMESTAMP,LOG) VALUES (TO_CHAR(SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BATCH DELETE STARTED ON IDN_RECOVERY_DATA...'')';
            END IF;
            EXECUTE IMMEDIATE 'DELETE FROM IDN_RECOVERY_DATA WHERE code IN (SELECT code FROM IDN_RECOVERY_DATA_BATCH_TMP where (:cleanUpCodesTimeLimit  > TIME_CREATED))'
            using  cleanUpCodesTimeLimit;
            rowCount:= sql%rowcount;
            COMMIT;
            IF (enableLog)
            THEN
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_CONFIRMATION_CODE_CLEANUP (TIMESTAMP,LOG) VALUES (TO_CHAR(SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BATCH DELETE FINISHED ON IDN_RECOVERY_DATA : '||rowCount||''')';
            END IF;

            -- DELETE FROM CHUNK
            EXECUTE IMMEDIATE 'DELETE FROM IDN_RECOVERY_DATA_CHUNK_TMP WHERE CODE IN (SELECT CODE FROM IDN_RECOVERY_DATA_BATCH_TMP)';
        END LOOP;
    END LOOP;

    -- DELETE TEMP TABLES
    EXECUTE IMMEDIATE 'DROP TABLE IDN_RECOVERY_DATA_BATCH_TMP';
    EXECUTE IMMEDIATE 'DROP TABLE IDN_RECOVERY_DATA_CHUNK_TMP';

    IF (enableLog)
    THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_CONFIRMATION_CODE_CLEANUP (TIMESTAMP,LOG) VALUES (TO_CHAR(SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP COMPLETED...!'')';
    END IF;

    COMMIT;
END;
/

CREATE OR REPLACE PROCEDURE WSO2_CONFIRMATION_CODE_CLEANUP_RESTORE IS
    -- ------------------------------------------
    -- DECLARE VARIABLES
    -- ------------------------------------------
    rowCount INT := 0;
    current_schema VARCHAR(20);

    -- ------------------------------------------
    -- CONFIGURABLE ATTRIBUTES
    -- ------------------------------------------
    enableLog BOOLEAN := TRUE; -- ENABLE LOGGING [DEFAULT : FALSE]

BEGIN

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO current_schema FROM DUAL;

    IF (enableLog)
    THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_CONFIRMATION_CODE_CLEANUP (TIMESTAMP,LOG) VALUES (TO_CHAR(SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION STARTED...!'')';
    END IF;

    SELECT COUNT(*) INTO rowCount FROM ALL_TABLES WHERE OWNER = current_schema AND table_name = 'IDN_RECOVERY_DATA';
    IF (rowCount = 1)
    THEN
        EXECUTE IMMEDIATE 'INSERT INTO IDN_RECOVERY_DATA SELECT A.* FROM BAK_IDN_RECOVERY_DATA A LEFT JOIN IDN_RECOVERY_DATA B ON A.CODE = B.CODE WHERE B.CODE IS NULL';
        rowCount:= sql%rowcount;
        IF (enableLog)
        THEN
            EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_CONFIRMATION_CODE_CLEANUP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION COMPLETED ON IDN_RECOVERY_DATA WITH '||rowCount||''')';
        END IF;
        COMMIT;
    END IF;

    IF (enableLog)
    THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_CONFIRMATION_CODE_CLEANUP (TIMESTAMP,LOG) VALUES (TO_CHAR(SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION COMPLETED...!'')';
        COMMIT;
    END IF;
END;

/

CREATE OR REPLACE PROCEDURE WSO2_CONFIRMATION_CODE_CLEANUP_SP IS 

    i INT := 0;
    chunk_size INT := 5000;
    number_of_rows INT := 0;
    
BEGIN

    SELECT COUNT(*) INTO number_of_rows from ALL_TABLES where table_name = upper('TEMP_REG_RESOURCE_INVALID_ID');
    IF (number_of_rows = 1) then
    EXECUTE IMMEDIATE 'DROP TABLE TEMP_REG_RESOURCE_INVALID_ID';
    COMMIT;
    END if;
    
    EXECUTE IMMEDIATE 'CREATE TABLE TEMP_REG_RESOURCE_INVALID_ID (REG_PROPERTY_ID INTEGER)';
    COMMIT;
    
    EXECUTE IMMEDIATE 'INSERT INTO TEMP_REG_RESOURCE_INVALID_ID (REG_PROPERTY_ID)
    SELECT REG_PROPERTY_ID
    FROM REG_RESOURCE_PROPERTY
    WHERE REG_PROPERTY_ID NOT IN ( 
        SELECT REG_PROPERTY_ID FROM REG_RESOURCE_PROPERTY 
        INNER JOIN REG_RESOURCE 
        ON REG_RESOURCE_PROPERTY.REG_PATH_ID = REG_RESOURCE.REG_PATH_ID
        UNION 
        SELECT REG_PROPERTY_ID FROM REG_RESOURCE_PROPERTY 
        INNER JOIN REG_RESOURCE  
        ON REG_RESOURCE_PROPERTY.REG_VERSION = REG_RESOURCE.REG_VERSION
    )';
    COMMIT;

    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM TEMP_REG_RESOURCE_INVALID_ID' INTO number_of_rows;
    WHILE (i <= number_of_rows/chunk_size) LOOP  					
        EXECUTE IMMEDIATE 'DELETE 
        FROM REG_RESOURCE_PROPERTY 
        WHERE REG_PROPERTY_ID 
        IN (
            SELECT REG_RESOURCE_PROPERTY.REG_PROPERTY_ID 
            FROM REG_RESOURCE_PROPERTY 
            INNER JOIN TEMP_REG_RESOURCE_INVALID_ID 
            ON REG_RESOURCE_PROPERTY.REG_PROPERTY_ID = TEMP_REG_RESOURCE_INVALID_ID.REG_PROPERTY_ID
            FETCH FIRST '||chunk_size||' ROWS ONLY
        )';
        COMMIT;	
                
        --DBMS_LOCK.sleep(2);
        
        EXECUTE IMMEDIATE 'DELETE 
        FROM REG_PROPERTY 
        WHERE REG_ID 
        IN (
            SELECT REG_PROPERTY.REG_ID 
            FROM REG_PROPERTY 
            INNER JOIN TEMP_REG_RESOURCE_INVALID_ID 
            ON REG_PROPERTY.REG_ID = TEMP_REG_RESOURCE_INVALID_ID.REG_PROPERTY_ID
            FETCH FIRST '||chunk_size||' ROWS ONLY
        )';
        COMMIT;	
        
        i := i + 1;
        --DBMS_LOCK.sleep(2);
    END LOOP; 

    EXECUTE IMMEDIATE 'DROP TABLE TEMP_REG_RESOURCE_INVALID_ID';
    COMMIT;
END;

/
CREATE OR REPLACE PROCEDURE WSO2_REG_LOG_CLEANUP
IS
-- ------------------------------------------
-- CONFIGURABLE VARIABLES
-- ------------------------------------------
batchSize INT := 10000;      -- SET BATCH SIZE FOR AVOID TABLE LOCKS    [DEFAULT : 10000]
chunkSize INT := 500000;    -- SET TEMP TABLE CHUNK SIZE FOR AVOID TABLE LOCKS    [DEFAULT : 500000]
sleepTime FLOAT := 5;          -- Sleep time in seconds.[DEFAULT : 2]
checkCount INT := 500; -- SET CHECK COUNT FOR FINISH CLEANUP SCRIPT (CLEANUP ELIGIBLE COUNT SHOULD BE HIGHER THAN checkCount TO CONTINUE) [DEFAULT : 1000]
backupTables BOOLEAN := TRUE;    -- SET TRUE IF REG PROPERTIES TO BACKUP BEFORE DELETE [DEFAULT : FALSE]. WILL DROP THE PREVIOUS BACKUP TABLES IN NEXT ITERATION
enableLog BOOLEAN := TRUE ; -- ENABLE LOGGING [DEFAULT : TRUE]
logLevel VARCHAR(10) := 'TRACE'; -- SET LOG LEVELS : TRACE , DEBUG
rowCount INT := 0;
CURRENT_SCHEMA VARCHAR(20);
cleanupCount INT := 0;
chunkCount INT := 0;
batchCount INT := 0;
backupTable VARCHAR(50);
cursorTable VARCHAR(50);

CURSOR backupTablesCursor is
SELECT TABLE_NAME FROM ALL_TABLES WHERE OWNER = CURRENT_SCHEMA AND
TABLE_NAME IN ('REG_LOG');

BEGIN
-- ------------------------------------------------------
-- CREATING LOG TABLE REG_LOG_CLEANUP
-- ------------------------------------------------------

SELECT SYS_CONTEXT( 'USERENV', 'CURRENT_SCHEMA' ) INTO CURRENT_SCHEMA FROM DUAL;

IF (enableLog)
THEN
SELECT COUNT(*) INTO rowCount from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('LOG_WSO2_REG_LOG_CLEANUP_SP');
    IF (rowCount = 1) then
    EXECUTE IMMEDIATE 'DROP TABLE LOG_WSO2_REG_LOG_CLEANUP_SP';
    COMMIT;
    END if;
EXECUTE IMMEDIATE 'CREATE TABLE LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP VARCHAR(250) , LOG VARCHAR(250)) NOLOGGING';
COMMIT;
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''WSO2_REG_LOG_CLEANUP_SP STARTED .... !'')';
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''USING SCHEMA :'||CURRENT_SCHEMA||''')';
COMMIT;
END IF;


-- ------------------------------------------------------
-- BACKUP TABLES
-- ------------------------------------------------------


IF (backupTables)
THEN
      IF (enableLog)
      THEN
          EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TABLE BACKUP STARTED ... !'')';
          COMMIT;
      END IF;

      FOR cursorTable IN backupTablesCursor
      LOOP

      SELECT REPLACE(''||cursorTable.TABLE_NAME||'','REG_LOG','REG_LOG_BACKUP') INTO backupTable FROM DUAL;

      IF (enableLog AND logLevel IN ('TRACE'))
      THEN
          EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BACKING UP TABLE OF '||cursorTable.TABLE_NAME||' CREATING AS '||backupTable||''')';
          COMMIT;
      END IF;

      SELECT COUNT(*) INTO rowCount from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper(backupTable);
      IF (ROWCOUNT = 1)
      THEN
          EXECUTE IMMEDIATE 'DROP TABLE '||backupTable;
          COMMIT;
      END if;

      EXECUTE IMMEDIATE 'CREATE TABLE '||backupTable||' AS (SELECT * FROM '||cursorTable.TABLE_NAME||' WHERE 1 = 2)';
      COMMIT;

      IF (enableLog  AND logLevel IN ('TRACE','DEBUG') )
      THEN
          EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BACKING UP TABLE CREATION FOR '||cursorTable.TABLE_NAME||' COMPLETED '')';
          COMMIT;
      END IF;

      END LOOP;
      IF (enableLog)
      THEN
          EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
          COMMIT;
      END IF;
END IF;


-- ------------------------------------------
-- PURGE REG_LOG
-- ------------------------------------------
LOOP

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE REG_LOG_CHUNK_TMP';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

EXECUTE IMMEDIATE 'CREATE TABLE REG_LOG_CHUNK_TMP AS SELECT REG_LOG_ID FROM (
  (SELECT RL.REG_LOG_ID FROM REG_LOG RL LEFT JOIN (
  SELECT MAX(REG_LOG_ID) AS REG_LOG_ID FROM REG_LOG GROUP BY REG_PATH, REG_TENANT_ID) X
  ON RL.REG_LOG_ID = X.REG_LOG_ID
  WHERE X.REG_LOG_ID IS NULL)
  UNION
  (SELECT REG_LOG_ID FROM REG_LOG WHERE REG_ACTION = 7)
    ) A WHERE rownum <= '||batchSize||'' ;

chunkCount := SQL%rowcount;

IF (chunkCount < checkCount OR chunkCount=0)
THEN
IF (chunkCount < checkCount)
THEN
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''EXIT LOOP HENCE DELETE ELIGIBLE COUNT IS LESS THAN CHECK_COUNT DEFINED'')';
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DELETE ELIGIBLE : '||chunkCount||''')';
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CHECK COUNT : '||checkCount||''')';
END IF;
EXIT;
END IF;


IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
THEN
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''REG_LOG_CHUNK_TMP TABLE CREATED WITH : '||checkCount||''')';
END IF;

EXECUTE IMMEDIATE 'CREATE INDEX REG_LOG_CHUNK_TMP_INDX on REG_LOG_CHUNK_TMP (REG_LOG_ID)';

COMMIT;

        LOOP

        BEGIN
           EXECUTE IMMEDIATE 'DROP TABLE REG_LOG_BATCH_TMP';
        EXCEPTION
           WHEN OTHERS THEN
              IF SQLCODE != -942 THEN
                 RAISE;
              END IF;
        END;

        EXECUTE IMMEDIATE 'CREATE TABLE REG_LOG_BATCH_TMP AS SELECT REG_LOG_ID FROM REG_LOG_CHUNK_TMP WHERE rownum <= '||batchSize||'';

        batchCount := SQL%rowcount;

		IF (batchCount=0)
        THEN
        EXIT;
        END IF;

        IF (backupTables)
        THEN
        IF (enableLog AND logLevel IN ('TRACE'))
        THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BACKING UP TABLE REG_LOG_BACKUP'')';
        END IF;
        EXECUTE IMMEDIATE 'INSERT INTO REG_LOG_BACKUP SELECT RL.* FROM  REG_LOG RL INNER JOIN  REG_LOG_BATCH_TMP  RLB ON RL.REG_LOG_ID = RLB.REG_LOG_ID';
        COMMIT;
        END IF;

        IF (enableLog AND logLevel IN ('TRACE'))
        THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BATCH DELETE STARTED ON REG_LOG: '||batchCount||''')';
        END IF;

        EXECUTE IMMEDIATE 'DELETE FROM REG_LOG where REG_LOG_ID IN (SELECT REG_LOG_ID FROM REG_LOG_BATCH_TMP)';

        rowCount := SQL%rowcount;
		COMMIT;
        IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
        THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BATCH DELETE FINISHED ON REG_LOG:  '||rowCount||''')';
        END IF;

        IF (enableLog AND logLevel IN ('TRACE'))
        THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BATCH DELETE STARTED ON REG_LOG_CHUNK_TMP :  '||batchCount||''')';
        END IF;

        EXECUTE IMMEDIATE 'DELETE FROM REG_LOG_CHUNK_TMP where REG_LOG_ID IN (SELECT REG_LOG_ID FROM REG_LOG_BATCH_TMP)';

		COMMIT;
        IF (enableLog AND logLevel IN ('TRACE'))
        THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BATCH DELETE FINISHED ON REG_LOG_CHUNK_TMP'')';
        END IF;

        IF ((rowCount > 0))
        THEN
            IF (enableLog AND logLevel IN ('TRACE'))
        THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''SLEEPING FOR SECONDS :  '||sleepTime||''')';
        END IF;
        --dbms_lock.sleep(sleeptime);
        END IF;
        END LOOP;

END LOOP;

-- CLEANUP ANY EXISTING TEMP TABLES
IF (enableLog AND logLevel IN ('TRACE'))
THEN
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DROP TEMP TABLES REG_LOG_CHUNK_TMP'')';
BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE REG_LOG_CHUNK_TMP';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE REG_LOG_BATCH_TMP';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
END IF;

-- ------------------------------------------------------
-- CALCULATING REG_LOG
-- ------------------------------------------------------
IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
THEN
    SELECT  COUNT(1) into rowCount FROM REG_LOG;
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL REG_LOG TABLE AFTER DELETE :  '||rowCount||''')';
END IF;

IF (enableLog)
THEN
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_REG_LOG_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''WSO2_REG_LOG_CLEANUP TASK COMPLETED .... !'')';
END IF;
END;

/

CREATE OR REPLACE PROCEDURE wso2_session_cleanup_sp IS


-- ------------------------------------------
-- DECLARE VARIABLES (DO NO CHANGE THESE VALUES)
-- ------------------------------------------

    deletedsessions                  INT := 0;
    deletedmappingsessions           INT := 0;
    deletedsessionapppinfo           INT := 0;
    deletedsessionmetadata           INT := 0;
    deletedstoreoperations           INT := 0;
    deletedopsessionmappings         INT := 0;
    deletedopsessionapppinfo         INT := 0;
    deletedopsessionmetadata         INT := 0;
    unixtime                         INT := 0;
    rowcount                         INT := 0;
    sessioncleanuptime               INT := 0;
    opcleanuptime                    INT := 0;
    current_schema                   VARCHAR(20);
    sessioncleanupcount              INT := 0;
    sessionmappingcleanupcount       INT := 0;
    opmappingcleanupcount            INT := 0;
    sessionappinfocleanupcount       INT := 0;
    opappinfocleanupcount            INT := 0;
    sessionmetadatacleanupcount      INT := 0;
    opmetadatacleanupcount           INT := 0;
    opcleanupcount                   INT := 0;
    expiredsessioncount              INT := 0;

-- ------------------------------------------
-- CONFIGURABLE VARIABLES
-- ------------------------------------------
    batchsize                        INT := 10000;      -- BATCH WISE DELETE [DEFULT : 10000]
    chunklimit                       INT := 500000;     -- CHUNK WISE DELETE FOR LARGE TABLES [DEFULT : 500000]
    checkcount                       INT := 100;        -- SET CHECK COUNT FOR FINISH CLEANUP SCRIPT (CLEANUP ELIGIBLE SESSION COUNT SHOULD BE HIGHER THAN checkCount TO CONTINUE) [DEFAULT : 100]
    tracingenabled                   BOOLEAN := TRUE;   --  IF TRACE LOGGING IS ENABLED [DEFAULT : TRUE]
    sleeptime                        INT := 2;          -- Sleep time in seconds.
    sessnclntiminminits              INT := 120;      -- Expired Session data older than 120 minutes (2 hours) will be removed.
    opertnclntimeinminits            INT := 720;        -- Operational data older than 720 minutes (12 h) will be removed.

BEGIN


    SELECT trunc((TO_DATE(TO_CHAR(sys_extract_utc(systimestamp), 'YYYY-MM-DD HH24:MI:SS'), 'YYYY-MM-DD HH24:MI:SS') - TO_DATE('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) * 86400) INTO unixtime FROM DUAL;

    sessioncleanuptime := unixtime * 1000000000 - ( sessnclntiminminits * 60000000000 );
    opcleanuptime := unixtime * 1000000000 - ( opertnclntimeinminits * 60000000000 );

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO current_schema FROM DUAL;

    IF ( tracingenabled ) THEN
        SELECT COUNT(*) INTO rowcount FROM all_tables WHERE owner = current_schema AND table_name = upper('LOG_WSO2_SESSION_CLEANUP_SP');
        IF ( rowcount = 1 ) THEN
            EXECUTE IMMEDIATE 'DROP TABLE LOG_WSO2_SESSION_CLEANUP_SP';
            COMMIT;
        END IF;
        EXECUTE IMMEDIATE 'CREATE TABLE LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP VARCHAR(250) , LOG VARCHAR(250)) NOLOGGING';
        COMMIT;
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''WSO2_SESSION_CLEANUP_SP STARTED .... !'')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''USING SCHEMA :'|| current_schema|| ''')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''SESSION DATA CLEANUP TIME AFTER : '||sessioncleanuptime|| ''')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''OPERATIONS DATA CLEANUP TIME AFTER : '||opcleanuptime|| ''')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
        COMMIT;
    END IF;


-- ------------------------------------------
-- REMOVE SESSION DATA
-- ------------------------------------------
    IF ( tracingenabled ) THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''SESSION_CLEANUP_TASK STARTED .... !'')';
        COMMIT;
    END IF;


    LOOP
        SELECT COUNT(1) INTO rowcount FROM all_tables WHERE owner = current_schema AND table_name = 'IDN_AUTH_SESSION_STORE_TMP';
        IF ( rowcount = 1 ) THEN
            EXECUTE IMMEDIATE 'DROP TABLE IDN_AUTH_SESSION_STORE_TMP';
            COMMIT;
        END IF;

--        EXECUTE IMMEDIATE 'CREATE TABLE IDN_AUTH_SESSION_STORE_TMP AS SELECT SESSION_ID FROM IDN_AUTH_SESSION_STORE WHERE 1=2';
        EXECUTE IMMEDIATE 'CREATE TABLE IDN_AUTH_SESSION_STORE_TMP (ROW_ID rowid,SESSION_ID varchar(100),CONSTRAINT CHNK_IASS_PRI PRIMARY KEY (ROW_ID)) NOLOGGING';

        EXECUTE IMMEDIATE 'INSERT INTO IDN_AUTH_SESSION_STORE_TMP SELECT rowid,SESSION_ID FROM IDN_AUTH_SESSION_STORE WHERE  rownum <= :chunklimit AND EXPIRY_TIME < :sessionCleanupTime'
        USING chunklimit, sessioncleanuptime;
        rowcount := SQL%rowcount;

--        EXECUTE IMMEDIATE 'CREATE INDEX idn_auth_session_tmp_idx on IDN_AUTH_SESSION_STORE_TMP (SESSION_ID)';
        COMMIT;

        EXIT WHEN rowcount <= checkcount;

        IF ( tracingenabled ) THEN
            EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
            EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TEMPORARY IDN_AUTH_SESSION_STORE_TMP CHUNK TABLE CREATED WITH '||rowcount||''')';
            COMMIT;
        END IF;

        LOOP
            SELECT COUNT(1) INTO rowcount FROM all_tables WHERE owner = current_schema AND table_name = 'TEMP_SESSION_BATCH';

            IF ( rowcount = 1 ) THEN
                EXECUTE IMMEDIATE 'DROP TABLE TEMP_SESSION_BATCH';
                COMMIT;
            END IF;
            
            EXECUTE IMMEDIATE 'CREATE TABLE TEMP_SESSION_BATCH (ROW_ID rowid,SESSION_ID varchar(100),CONSTRAINT BATCH_IASS_PRI PRIMARY KEY (ROW_ID)) NOLOGGING';
            COMMIT;
--            EXECUTE IMMEDIATE 'CREATE TABLE  TEMP_SESSION_BATCH AS SELECT SESSION_ID FROM IDN_AUTH_SESSION_STORE_TMP WHERE 1=2';

            EXECUTE IMMEDIATE 'INSERT INTO TEMP_SESSION_BATCH SELECT ROW_ID,SESSION_ID FROM IDN_AUTH_SESSION_STORE_TMP WHERE rownum <= :batchSize'
            USING batchsize;
            rowcount := SQL%rowcount;
            COMMIT;

            EXIT WHEN rowcount = 0;

            IF ( tracingenabled ) THEN
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TEMPORARY TEMP_SESSION_BATCH TABBLE CREATED WITH '|| rowcount||''')';
                COMMIT;
            END IF;

            EXECUTE IMMEDIATE 'DELETE FROM IDN_AUTH_SESSION_STORE WHERE rowid IN (SELECT ROW_ID FROM TEMP_SESSION_BATCH)';
            sessioncleanupcount := SQL%rowcount;
            COMMIT;

            IF ( tracingenabled ) THEN
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DELETED SESSIONS COMPLETED WITH '|| sessioncleanupcount||''')';
                COMMIT;
            END IF;

            EXECUTE IMMEDIATE 'DELETE FROM IDN_AUTH_SESSION_STORE_TMP WHERE ROW_ID IN (SELECT ROW_ID FROM TEMP_SESSION_BATCH)';
            COMMIT;

            IF ( tracingenabled ) THEN
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''REMOVED THE BATCH FROM CHUNK TABLE IDN_AUTH_SESSION_STORE_TMP'')';
                COMMIT;
            END IF;

            IF ( tracingenabled ) THEN
                deletedsessions := deletedsessions + sessioncleanupcount;
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL REMOVED SESSIONS COMPLETED WITH '|| deletedsessions||''')';
                COMMIT;
            END IF;

            --dbms_lock.sleep(sleeptime);
        END LOOP;

    END LOOP;

    IF ( tracingenabled ) THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''SESSION_CLEANUP_TASK COMPLETED REMOVING '||deletedsessions||' SESSIONS'')';
        COMMIT;
    END IF;

-- --------------------------------------------
-- REMOVE USER SESSION DATA FROM IDN_AUTH_USER_SESSION_MAPPING, IDN_AUTH_SESSION_APP_INFO, IDN_AUTH_SESSION_META_DATA TABLES
-- --------------------------------------------

    IF ( tracingenabled ) THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''USER_SESSION_TABLES_CLEANUP_TASK STARTED .... !'')';
        COMMIT;
    END IF;

    SELECT COUNT(*) INTO rowcount from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('IDN_AUTH_USER_SESSION_MAPPING');
    IF (rowcount = 1) THEN

        SELECT COUNT(1) INTO rowcount FROM all_tables WHERE owner = current_schema AND table_name = 'IDN_AUTH_EXPIRED_SESSION_TMP';
        IF ( rowcount = 1 ) THEN
            EXECUTE IMMEDIATE 'DROP TABLE IDN_AUTH_EXPIRED_SESSION_TMP';
            COMMIT;
        END IF;

        EXECUTE IMMEDIATE 'CREATE TABLE IDN_AUTH_EXPIRED_SESSION_TMP (SESSION_ID varchar(100),CONSTRAINT IDN_AUTH_EXP_SESS_PRI PRIMARY KEY (SESSION_ID)) NOLOGGING';
        EXECUTE IMMEDIATE 'INSERT INTO IDN_AUTH_EXPIRED_SESSION_TMP SELECT IDN_AUTH_USER_SESSION_MAPPING.SESSION_ID FROM IDN_AUTH_USER_SESSION_MAPPING LEFT OUTER JOIN IDN_AUTH_SESSION_STORE ON IDN_AUTH_USER_SESSION_MAPPING.SESSION_ID = IDN_AUTH_SESSION_STORE.SESSION_ID WHERE IDN_AUTH_SESSION_STORE.SESSION_ID IS NULL';
        expiredsessioncount := SQL%rowcount;
        COMMIT;

        IF ( tracingenabled ) THEN
            EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TEMPORARY IDN_AUTH_EXPIRED_SESSION_TMP TABLE CREATED WITH '||expiredsessioncount||''')';
            COMMIT;
        END IF;

        IF (expiredsessioncount > 0) THEN
        LOOP

            SELECT COUNT(1) INTO rowcount FROM all_tables WHERE owner = current_schema AND table_name = 'IDN_AUTH_USER_SESSION_TMP';
            IF ( rowcount = 1 ) THEN
                EXECUTE IMMEDIATE 'DROP TABLE IDN_AUTH_USER_SESSION_TMP';
                COMMIT;
            END IF;

            EXECUTE IMMEDIATE 'CREATE TABLE IDN_AUTH_USER_SESSION_TMP (SESSION_ID varchar(100),CONSTRAINT CHNK_IDN_USER_SESS_PRI PRIMARY KEY (SESSION_ID)) NOLOGGING';
            EXECUTE IMMEDIATE 'INSERT INTO IDN_AUTH_USER_SESSION_TMP SELECT SESSION_ID FROM IDN_AUTH_EXPIRED_SESSION_TMP WHERE rownum <= :chunklimit'
            USING chunklimit;
            rowcount := SQL%rowcount;
            COMMIT;

            EXIT WHEN rowcount <= checkcount;

            IF ( tracingenabled ) THEN
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TEMPORARY IDN_AUTH_USER_SESSION_TMP CHUNK TABLE CREATED WITH '||rowcount||''')';
                COMMIT;
            END IF;

            LOOP
                SELECT COUNT(1) INTO rowcount FROM all_tables WHERE owner = current_schema AND table_name = 'TEMP_USER_SESSION_BATCH';

                IF ( rowcount = 1 ) THEN
                    EXECUTE IMMEDIATE 'DROP TABLE TEMP_USER_SESSION_BATCH';
                    COMMIT;
                END IF;

                EXECUTE IMMEDIATE 'CREATE TABLE TEMP_USER_SESSION_BATCH (SESSION_ID varchar(100),CONSTRAINT BATCH_IDN_USER_SESS_PRI PRIMARY KEY (SESSION_ID)) NOLOGGING';
                COMMIT;

                EXECUTE IMMEDIATE 'INSERT INTO TEMP_USER_SESSION_BATCH SELECT SESSION_ID FROM IDN_AUTH_USER_SESSION_TMP WHERE rownum <= :batchSize'
                USING batchsize;
                rowcount := SQL%rowcount;
                COMMIT;

                EXIT WHEN rowcount = 0;

                IF ( tracingenabled ) THEN
                    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TEMPORARY TEMP_USER_SESSION_BATCH TABLE CREATED WITH '|| rowcount||''')';
                    COMMIT;
                END IF;

                -- Deleting user-session mappings from 'IDN_AUTH_USER_SESSION_MAPPING' table
                EXECUTE IMMEDIATE 'DELETE FROM IDN_AUTH_USER_SESSION_MAPPING WHERE SESSION_ID IN (SELECT SESSION_ID FROM TEMP_USER_SESSION_BATCH)';
                sessionmappingcleanupcount := SQL%rowcount;
                COMMIT;
                IF ( tracingenabled ) THEN
                    deletedmappingsessions := deletedmappingsessions + sessionmappingcleanupcount;
                    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DELETED USER-SESSION MAPPINGS COMPLETED WITH '|| sessionmappingcleanupcount||''')';
                    COMMIT;
                END IF;
                -- End of deleting user-session mappings from 'IDN_AUTH_USER_SESSION_MAPPING' table

                -- Deleting session app info from 'IDN_AUTH_SESSION_APP_INFO' table
                SELECT COUNT(*) INTO ROWCOUNT from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('IDN_AUTH_SESSION_APP_INFO');
                IF (ROWCOUNT = 1) then
                    EXECUTE IMMEDIATE 'DELETE FROM IDN_AUTH_SESSION_APP_INFO WHERE SESSION_ID IN (SELECT SESSION_ID FROM TEMP_USER_SESSION_BATCH)';
                    sessionappinfocleanupcount := SQL%rowcount;
                    COMMIT;
                    IF ( tracingenabled ) THEN
                        deletedsessionapppinfo := deletedsessionapppinfo + sessionappinfocleanupcount;
                        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DELETED SESSION APP INFO COMPLETED WITH '|| sessionappinfocleanupcount||''')';
                        COMMIT;
                    END IF;
                END if;
                -- End of deleting session app info from 'IDN_AUTH_SESSION_APP_INFO' table

                -- Deleting session metadata from 'IDN_AUTH_SESSION_META_DATA' table
                SELECT COUNT(*) INTO ROWCOUNT from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('IDN_AUTH_SESSION_META_DATA');
                IF (ROWCOUNT = 1) then
                    EXECUTE IMMEDIATE 'DELETE FROM IDN_AUTH_SESSION_META_DATA WHERE SESSION_ID IN (SELECT SESSION_ID FROM TEMP_USER_SESSION_BATCH)';
                    sessionmetadatacleanupcount := SQL%rowcount;
                    COMMIT;
                    IF ( tracingenabled ) THEN
                        deletedsessionmetadata := deletedsessionmetadata + sessionmetadatacleanupcount;
                        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DELETED SESSION METADATA COMPLETED WITH '|| sessionmetadatacleanupcount||''')';
                        COMMIT;
                    END IF;
                END if;
                -- End of deleting session metadata from 'IDN_AUTH_SESSION_META_DATA' table

                EXECUTE IMMEDIATE 'DELETE FROM IDN_AUTH_USER_SESSION_TMP WHERE SESSION_ID IN (SELECT SESSION_ID FROM TEMP_USER_SESSION_BATCH)';
                COMMIT;

                IF ( tracingenabled ) THEN
                    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''REMOVED THE BATCH FROM TABLE IDN_AUTH_USER_SESSION_TMP'')';
                    COMMIT;
                END IF;

                EXECUTE IMMEDIATE 'DELETE FROM IDN_AUTH_EXPIRED_SESSION_TMP WHERE SESSION_ID IN (SELECT SESSION_ID FROM TEMP_USER_SESSION_BATCH)';
                COMMIT;

                IF ( tracingenabled ) THEN
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''REMOVED THE BATCH FROM TABLE IDN_AUTH_EXPIRED_SESSION_TMP'')';
                COMMIT;
                END IF;

                --dbms_lock.sleep(sleeptime);
            END LOOP;

        END LOOP;
        END IF;
    END IF;

    IF ( tracingenabled ) THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''SESSION_CLEANUP_TASK COMPLETED REMOVING '||deletedmappingsessions||' USER-SESSION MAPPINGS'')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''SESSION_CLEANUP_TASK COMPLETED REMOVING '||deletedsessionapppinfo||' SESSION APP INFO ENTRIES'')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''SESSION_CLEANUP_TASK COMPLETED REMOVING '||deletedsessionmetadata||' SESSION METADATA ENTRIES'')';
        COMMIT;
    END IF;

-- --------------------------------------------
-- REMOVE OPERATIONAL DATA
-- --------------------------------------------

    IF ( tracingenabled ) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''OPERATION_CLEANUP_TASK STARTED .... !'')';
        COMMIT;
    END IF;


    LOOP

        SELECT COUNT(1) INTO rowcount FROM all_tables WHERE owner = current_schema AND table_name = 'IDN_AUTH_SESSION_STORE_TMP';

        IF ( rowcount = 1 ) THEN
            EXECUTE IMMEDIATE 'DROP TABLE IDN_AUTH_SESSION_STORE_TMP';
            COMMIT;
        END IF;

--        EXECUTE IMMEDIATE 'CREATE TABLE IDN_AUTH_SESSION_STORE_TMP AS SELECT SESSION_ID,SESSION_TYPE FROM IDN_AUTH_SESSION_STORE WHERE 1=2';
        EXECUTE IMMEDIATE 'CREATE TABLE IDN_AUTH_SESSION_STORE_TMP (ROW_ID rowid,SESSION_ID varchar(100),CONSTRAINT CHNK_IASS_PRI PRIMARY KEY (ROW_ID)) NOLOGGING';

        EXECUTE IMMEDIATE 'INSERT INTO IDN_AUTH_SESSION_STORE_TMP SELECT rowid,SESSION_ID FROM IDN_AUTH_SESSION_STORE WHERE rownum <= :chunklimit AND OPERATION = ''DELETE'' AND TIME_CREATED < :operationCleanupTime'
        USING chunklimit,opcleanuptime;
        rowcount := SQL%rowcount;

--        EXECUTE IMMEDIATE 'CREATE INDEX idn_auth_session_tmp_idx on IDN_AUTH_SESSION_STORE_TMP (SESSION_ID)';
--        COMMIT;

        EXIT WHEN rowcount <= checkcount;

        IF ( tracingenabled ) THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TEMPORARY IDN_AUTH_SESSION_STORE_TMP CHUNK TABLE CREATED WITH OPERATIONAL DATA '||rowcount||''')';
        COMMIT;
        END IF;

        LOOP

            SELECT COUNT(1) INTO rowcount  FROM all_tables WHERE owner = current_schema AND table_name = 'TEMP_SESSION_BATCH';

            IF ( rowcount = 1 ) THEN
            EXECUTE IMMEDIATE 'DROP TABLE TEMP_SESSION_BATCH';
            COMMIT;
            END IF;

--            EXECUTE IMMEDIATE 'CREATE TABLE TEMP_SESSION_BATCH AS SELECT SESSION_ID, SESSION_TYPE FROM IDN_AUTH_SESSION_STORE_TMP WHERE 1=2';
            EXECUTE IMMEDIATE 'CREATE TABLE TEMP_SESSION_BATCH (ROW_ID rowid,SESSION_ID varchar(100),CONSTRAINT BATCH_IASS_PRI PRIMARY KEY (ROW_ID)) NOLOGGING';
            COMMIT;

            EXECUTE IMMEDIATE 'INSERT INTO TEMP_SESSION_BATCH SELECT ROW_ID,SESSION_ID FROM IDN_AUTH_SESSION_STORE_TMP WHERE rownum <= :batchSize'
            USING batchsize;
            rowcount := SQL%rowcount;
            COMMIT;

            EXIT WHEN rowcount = 0;

            EXECUTE IMMEDIATE 'DELETE IDN_AUTH_SESSION_STORE WHERE rowid in (select ROW_ID from TEMP_SESSION_BATCH)';
            opcleanupcount := SQL%rowcount;
            COMMIT;

            IF ( tracingenabled ) THEN
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DELETED  STORE OPERATIONS COMPLETED WITH '||opcleanupcount||''')';
                COMMIT;
            END IF;

            -- Deleting operational data related user-session mappings from 'IDN_AUTH_USER_SESSION_MAPPING' table
            SELECT COUNT(*) INTO ROWCOUNT from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('IDN_AUTH_USER_SESSION_MAPPING');
            IF (ROWCOUNT = 1) then
                EXECUTE IMMEDIATE 'DELETE FROM IDN_AUTH_USER_SESSION_MAPPING WHERE SESSION_ID IN (SELECT SESSION_ID FROM TEMP_SESSION_BATCH)';
                opmappingcleanupcount := SQL%rowcount;
                COMMIT;
                IF ( tracingenabled ) THEN
                    deletedopsessionmappings := deletedopsessionmappings + opmappingcleanupcount;
                    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DELETED OPERATIONAL USER-SESSION MAPPINGS COMPLETED WITH '|| opmappingcleanupcount||''')';
                    COMMIT;
                END IF;
            END if;
            -- End of deleting operational data related user-session mappings from 'IDN_AUTH_USER_SESSION_MAPPING' table

            -- Deleting operational data related session app info from 'IDN_AUTH_SESSION_APP_INFO' table
            SELECT COUNT(*) INTO ROWCOUNT from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('IDN_AUTH_SESSION_APP_INFO');
            IF (ROWCOUNT = 1) then
                EXECUTE IMMEDIATE 'DELETE FROM IDN_AUTH_SESSION_APP_INFO WHERE SESSION_ID IN (SELECT SESSION_ID FROM TEMP_SESSION_BATCH)';
                opappinfocleanupcount := SQL%rowcount;
                COMMIT;
                IF ( tracingenabled ) THEN
                    deletedopsessionapppinfo := deletedopsessionapppinfo + opappinfocleanupcount;
                    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DELETED OPERATIONAL SESSION APP INFO COMPLETED WITH '|| opappinfocleanupcount||''')';
                    COMMIT;
                END IF;
            END if;
            -- End of deleting operational data related session app info from 'IDN_AUTH_SESSION_APP_INFO' table

            -- Deleting operational data related session metadata from 'IDN_AUTH_SESSION_META_DATA' table
            SELECT COUNT(*) INTO ROWCOUNT from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('IDN_AUTH_SESSION_META_DATA');
            IF (ROWCOUNT = 1) then
                EXECUTE IMMEDIATE 'DELETE FROM IDN_AUTH_SESSION_META_DATA WHERE SESSION_ID IN (SELECT SESSION_ID FROM TEMP_SESSION_BATCH)';
                opmetadatacleanupcount := SQL%rowcount;
                COMMIT;

                IF ( tracingenabled ) THEN
                    deletedopsessionmetadata := deletedopsessionmetadata + opmetadatacleanupcount;
                    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DELETED OPERATIONAL SESSION METADATA COMPLETED WITH '|| opmetadatacleanupcount||''')';
                    COMMIT;
                END IF;
            END IF;
            -- End of deleting operational data related session metadata from 'IDN_AUTH_SESSION_META_DATA' table

            EXECUTE IMMEDIATE 'DELETE IDN_AUTH_SESSION_STORE_TMP where ROW_ID in (select ROW_ID from TEMP_SESSION_BATCH)';
            COMMIT;

            IF ( tracingenabled ) THEN
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''REMOVED THE BATCH FROM CHUNK TABLE IDN_AUTH_SESSION_STORE_TMP'')';
                COMMIT;
            END IF;

            IF ( tracingenabled ) THEN
                deletedstoreoperations := deletedstoreoperations + opcleanupcount;
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL REMOVED OPERATIONS COMPLETED WITH '||deletedstoreoperations||''')';
                COMMIT;
            END IF;

            EXECUTE IMMEDIATE 'DROP TABLE TEMP_SESSION_BATCH';
            COMMIT;

            --dbms_lock.sleep(sleeptime);

        END LOOP;

    END LOOP;

    IF ( tracingenabled ) THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''OPERATION_CLEANUP_TASK COMPLETED REMOVING '||deletedstoreoperations||' OPERATIONS'')';
        COMMIT;
    END IF;

    IF ( tracingenabled ) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL REMOVED SESSIONS COMPLETED WITH '||deletedsessions||''')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL REMOVED OPERATIONS COMPLETED WITH '||deletedstoreoperations||''')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL REMOVED OPERATION RELATED USER SESSION MAPPINGS COMPLETED WITH '||deletedopsessionmappings||''')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL REMOVED OPERATION RELATED SESSION APP INFO COMPLETED WITH '||deletedopsessionapppinfo||''')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL REMOVED OPERATION RELATED SESSION METADATA COMPLETED WITH '||deletedopsessionmetadata||''')';
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_SESSION_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''WSO2_SESSION_CLEANUP_SP COMPLETED .... ! '')';
        COMMIT;
    END IF;

END;
 
/

CREATE OR REPLACE PROCEDURE WSO2_TOKEN_CLEANUP_SP IS

-- ------------------------------------------
-- VARIABLE DECLARATION
-- ------------------------------------------

systime TIMESTAMP := systimestamp;
utcTime TIMESTAMP := sys_extract_utc(systimestamp);
deleteCount INT := 0;
chunkCount INT := 0;
batchCount INT := 0;
ROWCOUNT INT := 0;
cleaupCount INT := 0;
maxValidityPeriod INT := 99999999999990;  -- IF THE VALIDITY PERIOD IS MORE THAN 3170.97 YEARS WILL SKIP THE CLEANUP PROCESS;
CURRENT_SCHEMA VARCHAR(20);
backupTable VARCHAR(50);
cursorTable VARCHAR(50);

CURSOR backupTablesCursor is
SELECT TABLE_NAME FROM ALL_TABLES WHERE OWNER = CURRENT_SCHEMA AND
TABLE_NAME IN ('IDN_OAUTH2_ACCESS_TOKEN', 'IDN_OAUTH2_AUTHORIZATION_CODE', 'IDN_OAUTH2_ACCESS_TOKEN_SCOPE','IDN_OIDC_REQ_OBJECT_REFERENCE','IDN_OIDC_REQ_OBJECT_CLAIMS','IDN_OIDC_REQ_OBJ_CLAIM_VALUES');

-- ------------------------------------------
-- CONFIGURABLE ATTRIBUTES
-- ------------------------------------------

batchSize INT := 10000; -- BATCH WISE DELETE [DEFULT : 10000]
chunkSize INT := 500000; -- CHUNK WISE DELETE FOR LARGE TABLES [DEFULT : 500000]
checkCount INT := 100; -- SET CHECK COUNT FOR FINISH CLEANUP SCRIPT (CLEANUP ELIGIBLE TOKENS COUNT SHOULD BE HIGHER THAN checkCount TO CONTINUE) [DEFAULT : 100]
backupTables BOOLEAN := TRUE;  -- SET IF TOKEN TABLE NEEDS TO BACKUP BEFORE DELETE [DEFAULT : TRUE] , WILL DROP THE PREVIOUS BACKUP TABLES IN NEXT ITERATION
sleepTime FLOAT :=2;  -- SET SLEEP TIME FOR AVOID TABLE LOCKS     [DEFAULT : 2]
safePeriod INT := 2; -- SET SLEEP TIME FOR AVOID TABLE LOCKS     [DEFAULT 2 in hours]
deleteTimeLimit TIMESTAMP := utcTime-safePeriod/24; -- SET CURRENT TIME - safePeriod FOR BEGIN THE TOKEN DELETE
enableLog BOOLEAN := TRUE ; -- ENABLE LOGGING [DEFAULT : TRUE]
logLevel VARCHAR(10) := 'TRACE'; -- SET LOG LEVELS : TRACE , DEBUG
enableAudit BOOLEAN := FALSE; -- SET TRUE FOR  KEEP TRACK OF ALL THE DELETED TOKENS USING A TABLE    [DEFAULT : FALSE] [# IF YOU ENABLE THIS TABLE BACKUP WILL FORCEFULLY SET TO TRUE]
enableStsGthrn BOOLEAN := FALSE; -- SET TRUE FOR GATHER SCHEMA LEVEL STATS TO IMPROVE QUERY PERFOMANCE [DEFAULT : FALSE]
enableRebuildIndexes BOOLEAN := FALSE; -- SET TRUE FOR REBUILD INDEXES TO IMPROVE QUERY PERFOMANCE [DEFAULT : FALSE]


BEGIN

-- ------------------------------------------------------
-- CREATING LOG TABLE IDN_OAUTH2_ACCESS_TOKEN
-- ------------------------------------------------------

SELECT SYS_CONTEXT( 'USERENV', 'CURRENT_SCHEMA' ) INTO CURRENT_SCHEMA FROM DUAL;

IF (enableLog)
THEN
SELECT COUNT(*) INTO ROWCOUNT from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('LOG_WSO2_TOKEN_CLEANUP_SP');
    IF (ROWCOUNT = 1) then
    EXECUTE IMMEDIATE 'DROP TABLE LOG_WSO2_TOKEN_CLEANUP_SP';
    COMMIT;
    END if;
EXECUTE IMMEDIATE 'CREATE TABLE LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP VARCHAR(250) , LOG VARCHAR(250)) NOLOGGING';
COMMIT;
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''WSO2_TOKEN_CLEANUP_SP STARTED .... !'')';
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''USING SCHEMA :'||CURRENT_SCHEMA||''')';
COMMIT;
END IF;


IF (enableAudit)
THEN
backupTables := TRUE;    -- BACKUP TABLES IS REQUIRED BE TRUE, HENCE THE AUDIT IS ENABLED.
END IF;

-- ------------------------------------------------------
-- BACKUP TABLES
-- ------------------------------------------------------


IF (backupTables)
THEN
      IF (enableLog)
      THEN
          EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TABLE BACKUP STARTED ... !'')';
          COMMIT;
      END IF;

      FOR cursorTable IN backupTablesCursor
      LOOP

      SELECT REPLACE(''||cursorTable.TABLE_NAME||'','IDN_','BAK_') INTO backupTable FROM DUAL;

      IF (enableLog AND logLevel IN ('TRACE'))
      THEN
          EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BACKING UP '||cursorTable.TABLE_NAME||' INTO '||backupTable||' STARTED '')';
          COMMIT;
      END IF;

      SELECT COUNT(*) INTO ROWCOUNT from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper(backupTable);
      IF (ROWCOUNT = 1)
      THEN
          EXECUTE IMMEDIATE 'DROP TABLE '||backupTable;
          COMMIT;
      END if;

      EXECUTE IMMEDIATE 'CREATE TABLE '||backupTable||' AS (SELECT * FROM '||cursorTable.TABLE_NAME||')';
      ROWCOUNT:= sql%rowcount;
      COMMIT;

      IF (enableLog  AND logLevel IN ('TRACE','DEBUG') )
      THEN
          EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BACKING UP '||cursorTable.TABLE_NAME||' COMPLETED WITH : '||ROWCOUNT||''')';
          COMMIT;
      END IF;

      END LOOP;
      IF (enableLog)
      THEN
          EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
          COMMIT;
      END IF;
END IF;


-- ------------------------------------------------------
-- CREATING AUDIT TABLES FOR TOKENS DELETION FOR THE FIRST TIME RUN
-- ------------------------------------------------------
IF (enableAudit)
THEN

    SELECT count(1) into ROWCOUNT FROM ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = 'ADT_OAUTH2_ACCESS_TOKEN';
    IF (ROWCOUNT =0 )
    THEN
        IF (enableLog  AND logLevel IN ('TRACE') )
        THEN
            EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CREATING AUDIT TABLE ADT_OAUTH2_ACCESS_TOKEN .. ! '')';
            COMMIT;
        END IF;
        EXECUTE IMMEDIATE 'CREATE TABLE ADT_OAUTH2_ACCESS_TOKEN as (SELECT * FROM IDN_OAUTH2_ACCESS_TOKEN WHERE 1 = 2)';
        COMMIT;
    ELSE
        IF (enableLog  AND logLevel IN ('TRACE') )
        THEN
            EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''USING AUDIT TABLE ADT_OAUTH2_ACCESS_TOKEN'')';
            COMMIT;
        END IF;
    END IF;

    SELECT count(1) into ROWCOUNT FROM ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = 'ADT_OAUTH2_AUTHORIZATION_CODE';
    IF (ROWCOUNT = 0)
    THEN
        IF (enableLog  AND logLevel IN ('TRACE') )
        THEN
            EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CREATING AUDIT TABLE ADT_OAUTH2_AUTHORIZATION_CODE .. ! '')';
            COMMIT;
        END IF;
        EXECUTE IMMEDIATE 'CREATE TABLE ADT_OAUTH2_AUTHORIZATION_CODE as (SELECT * FROM IDN_OAUTH2_AUTHORIZATION_CODE WHERE 1 = 2)';
        COMMIT;
    ELSE
        IF (enableLog  AND logLevel IN ('TRACE'))
        THEN
            EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''USING AUDIT TABLE ADT_OAUTH2_AUTHORIZATION_CODE'')';
            COMMIT;
        END IF;
    END IF;
      IF (enableLog  AND logLevel IN ('TRACE'))
      THEN
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
        COMMIT;
      END IF;

END IF;


---- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
---- CALCULATING TOKENS TYPES IN IDN_OAUTH2_ACCESS_TOKEN
---- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
IF (enableLog)
THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CALCULATING TOKENS TYPES IN IDN_OAUTH2_ACCESS_TOKEN TABLE .... !'')';
    COMMIT;

    IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
    THEN
        SELECT COUNT(1) INTO ROWCOUNT FROM IDN_OAUTH2_ACCESS_TOKEN;
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL TOKENS ON IDN_OAUTH2_ACCESS_TOKEN TABLE BEFORE DELETE : '||ROWCOUNT||''')';
        COMMIT;
    END IF;

    IF (enableLog AND logLevel IN ('TRACE'))
    THEN
        SELECT COUNT(1) INTO cleaupCount FROM IDN_OAUTH2_ACCESS_TOKEN WHERE TOKEN_STATE IN ('EXPIRED','INACTIVE','REVOKED') OR
        (TOKEN_STATE in('ACTIVE') AND
        (VALIDITY_PERIOD BETWEEN 0 and maxValidityPeriod) AND (REFRESH_TOKEN_VALIDITY_PERIOD BETWEEN 0 and maxValidityPeriod) AND
        (deleteTimeLimit > (TIME_CREATED +  NUMTODSINTERVAL( VALIDITY_PERIOD / 60000, 'MINUTE' ))  ) AND
        (deleteTimeLimit > (REFRESH_TOKEN_TIME_CREATED +  NUMTODSINTERVAL( REFRESH_TOKEN_VALIDITY_PERIOD / 60000, 'MINUTE' ))));
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL TOKENS SHOULD BE DELETED FROM IDN_OAUTH2_ACCESS_TOKEN : '||cleaupCount||''')';
        COMMIT;
    END IF;

    IF (enableLog AND logLevel IN ('TRACE'))
    THEN
        ROWCOUNT := (ROWCOUNT - cleaupCount);
        EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL TOKENS SHOULD BE RETAIN IN IDN_OAUTH2_ACCESS_TOKEN : '||ROWCOUNT||''')';
        COMMIT;
    END IF;
END IF;

-- ------------------------------------------------------
-- BATCH DELETE IDN_OAUTH2_ACCESS_TOKEN
-- ------------------------------------------------------
IF (enableLog)
THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOKEN DELETE ON IDN_OAUTH2_ACCESS_TOKEN TABLE STARTED ... ! '')';
    COMMIT;
END IF;

LOOP
      SELECT COUNT(*) INTO ROWCOUNT from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('CHUNK_IDN_OAUTH2_ACCESS_TOKEN');
      IF (ROWCOUNT = 1) then
          EXECUTE IMMEDIATE 'DROP TABLE CHUNK_IDN_OAUTH2_ACCESS_TOKEN';
          COMMIT;
      END if;

      EXECUTE IMMEDIATE 'CREATE TABLE CHUNK_IDN_OAUTH2_ACCESS_TOKEN (ROW_ID rowid,CONSTRAINT CHNK_IDN_OATH_ACCS_TOK_PRI PRIMARY KEY (ROW_ID)) NOLOGGING';
      COMMIT;
      EXECUTE IMMEDIATE 'INSERT /*+ APPEND */ INTO CHUNK_IDN_OAUTH2_ACCESS_TOKEN (ROW_ID) SELECT rowid FROM IDN_OAUTH2_ACCESS_TOKEN WHERE rownum <= :chkSize AND (TOKEN_STATE IN (''EXPIRED'',''INACTIVE'',''REVOKED'') OR
      (TOKEN_STATE in (''ACTIVE'') AND (VALIDITY_PERIOD BETWEEN 0 and :mxValdPrid) AND (REFRESH_TOKEN_VALIDITY_PERIOD BETWEEN 0 and :mxValdPrid) AND
      ( :dtl > (TIME_CREATED +  NUMTODSINTERVAL( VALIDITY_PERIOD / 60000, ''MINUTE'' )) ) AND
      ( :dtl > (REFRESH_TOKEN_TIME_CREATED +  NUMTODSINTERVAL( REFRESH_TOKEN_VALIDITY_PERIOD / 60000, ''MINUTE'' )))))' using chunkSize,maxValidityPeriod,maxValidityPeriod,deleteTimeLimit,deleteTimeLimit;
      chunkCount:=  sql%Rowcount;
      COMMIT;

      EXIT WHEN chunkCount < checkCount ;

      IF (enableLog AND logLevel IN ('TRACE'))
      THEN
          EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CHUNK TABLE CHUNK_IDN_OAUTH2_ACCESS_TOKEN CREATED WITH : '||chunkCount||''')';
          COMMIT;
      END IF;

      IF (enableAudit)
      THEN
          EXECUTE IMMEDIATE 'INSERT INTO ADT_OAUTH2_ACCESS_TOKEN SELECT TOK.* FROM IDN_OAUTH2_ACCESS_TOKEN TOK , CHUNK_IDN_OAUTH2_ACCESS_TOKEN CHK WHERE TOK.ROWID=CHK.ROW_ID';
          COMMIT;
      END IF;

      LOOP
          SELECT COUNT(*) INTO ROWCOUNT from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('BATCH_IDN_OAUTH2_ACCESS_TOKEN');
          IF (ROWCOUNT = 1) then
              EXECUTE IMMEDIATE 'DROP TABLE BATCH_IDN_OAUTH2_ACCESS_TOKEN';
              COMMIT;
          END IF;

          EXECUTE IMMEDIATE 'CREATE TABLE BATCH_IDN_OAUTH2_ACCESS_TOKEN (ROW_ID rowid,CONSTRAINT BATCH_IDN_OATH_ACCS_TOK_PRI PRIMARY KEY (ROW_ID)) NOLOGGING';
          COMMIT;

          EXECUTE IMMEDIATE 'INSERT /*+ APPEND */ INTO BATCH_IDN_OAUTH2_ACCESS_TOKEN (ROW_ID) SELECT ROW_ID FROM CHUNK_IDN_OAUTH2_ACCESS_TOKEN WHERE rownum <= '||batchSize||'';
          batchCount:= sql%rowcount;
          COMMIT;

          EXIT WHEN batchCount = 0 ;

          IF (enableLog AND logLevel IN ('TRACE'))
              THEN
              EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BATCH DELETE START ON TABLE IDN_OAUTH2_ACCESS_TOKEN WITH : '||batchCount||''')';
              COMMIT;
          END IF;

          IF ((batchCount > 0))
          THEN
              EXECUTE IMMEDIATE 'DELETE IDN_OAUTH2_ACCESS_TOKEN where rowid in (select ROW_ID from  BATCH_IDN_OAUTH2_ACCESS_TOKEN)';
              deleteCount:= sql%rowcount;
          COMMIT;
          END IF;

          IF (enableLog)
          THEN
              EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BATCH DELETE FINISHED ON IDN_OAUTH2_ACCESS_TOKEN WITH : '||deleteCount||''')';
              COMMIT;
          END IF;

          EXECUTE IMMEDIATE 'DELETE CHUNK_IDN_OAUTH2_ACCESS_TOKEN WHERE ROW_ID in (select ROW_ID from BATCH_IDN_OAUTH2_ACCESS_TOKEN)';
          COMMIT;

          IF (enableLog AND logLevel IN ('TRACE'))
          THEN
              EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DELETED BATCH ON  CHUNK_IDN_OAUTH2_ACCESS_TOKEN !'')';
              COMMIT;
          END IF;

          IF ((deleteCount > 0))
          THEN
              IF (enableLog AND logLevel IN ('TRACE'))
              THEN
              EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''SLEEPING ...'')';
              COMMIT;
              END IF;
          --DBMS_LOCK.SLEEP(sleepTime);
          END IF;
      END LOOP;
END LOOP;

IF (enableLog)
THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BATCH DELETE ON IDN_OAUTH2_ACCESS_TOKEN COMPLETED .... !'')';
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
END IF;
COMMIT;

-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- CALCULATING CODE TYPES IN IDN_OAUTH2_AUTHORIZATION_CODE
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
IF (enableLog )
THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CALCULATING CODE TYPES IN IDN_OAUTH2_AUTHORIZATION_CODE TABLE .... !'')';
    COMMIT;
    IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
    THEN
    SELECT count(1) into ROWCOUNT FROM IDN_OAUTH2_AUTHORIZATION_CODE;
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL CODES ON IDN_OAUTH2_AUTHORIZATION_CODE TABLE BEFORE DELETE : '||ROWCOUNT||''')';
    COMMIT;
    END IF;
    -- -------------
    IF (enableLog AND logLevel IN ('TRACE'))
    THEN
    SELECT COUNT(1) into cleaupCount FROM IDN_OAUTH2_AUTHORIZATION_CODE WHERE CODE_ID IN
    (SELECT CODE_ID FROM IDN_OAUTH2_AUTHORIZATION_CODE code WHERE NOT EXISTS (SELECT * FROM IDN_OAUTH2_ACCESS_TOKEN tok where tok.TOKEN_ID = code.TOKEN_ID))
    AND (((VALIDITY_PERIOD BETWEEN 0 and maxValidityPeriod) AND deleteTimeLimit > (TIME_CREATED + NUMTODSINTERVAL( VALIDITY_PERIOD / 60000, 'MINUTE' ))) OR STATE ='INACTIVE');

    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL CODES SHOULD BE DELETED FROM IDN_OAUTH2_AUTHORIZATION_CODE : '||cleaupCount||''')';
    COMMIT;
    END IF;
    -- -------------
    IF (enableLog AND logLevel IN ('TRACE'))
    THEN
    ROWCOUNT := (ROWCOUNT - cleaupCount);
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL CODES SHOULD BE RETAIN IN IDN_OAUTH2_AUTHORIZATION_CODE : '||ROWCOUNT||''')';
    COMMIT;
    END IF;
END IF;
----

-- ------------------------------------------------------
-- BATCH DELETE IDN_OAUTH2_AUTHORIZATION_CODE
-- -- ------------------------------------------------------
IF (enableLog)
THEN
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CODES DELETE ON IDN_OAUTH2_AUTHORIZATION_CODE TABLE STARTED ... !'')';
COMMIT;
END IF;
----
LOOP
      SELECT COUNT(*) INTO ROWCOUNT from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('CHNK_IDN_OATH_AUTHRIZATN_CODE');
      IF (ROWCOUNT = 1) then
      EXECUTE IMMEDIATE 'DROP TABLE CHNK_IDN_OATH_AUTHRIZATN_CODE';
      COMMIT;
      END if;

      EXECUTE IMMEDIATE 'CREATE TABLE CHNK_IDN_OATH_AUTHRIZATN_CODE (ROW_ID rowid,CONSTRAINT CHNK_IDN_OATH_AUTHRIZN_PRI PRIMARY KEY (ROW_ID)) NOLOGGING';
      COMMIT;

      EXECUTE IMMEDIATE 'INSERT /*+ APPEND */ INTO CHNK_IDN_OATH_AUTHRIZATN_CODE (ROW_ID) SELECT rowid FROM IDN_OAUTH2_AUTHORIZATION_CODE WHERE rownum <= :chkSize AND CODE_ID IN
      (SELECT CODE_ID FROM IDN_OAUTH2_AUTHORIZATION_CODE code WHERE NOT EXISTS (SELECT * FROM IDN_OAUTH2_ACCESS_TOKEN tok where tok.TOKEN_ID = code.TOKEN_ID))
      AND (((VALIDITY_PERIOD BETWEEN 0 and :mxValdPrid) AND :dTL > (TIME_CREATED + NUMTODSINTERVAL( VALIDITY_PERIOD / 60000, ''MINUTE'' ))) OR STATE =''INACTIVE'')' using chunkSize,maxValidityPeriod,deleteTimeLimit ;

      chunkCount:=  sql%Rowcount;
      COMMIT;

      EXIT WHEN chunkCount < checkCount ;
      IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
      THEN
      EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CHUNK TABLE CHNK_IDN_OATH_AUTHRIZATN_CODE CREATED WITH : '||chunkCount||''')';
      COMMIT;
      END IF;

      IF (enableAudit)
      THEN
      EXECUTE IMMEDIATE 'INSERT INTO ADT_OAUTH2_AUTHORIZATION_CODE SELECT CODE.* FROM IDN_OAUTH2_AUTHORIZATION_CODE CODE , CHNK_IDN_OATH_AUTHRIZATN_CODE CHK WHERE CODE.ROWID=CHK.ROW_ID';
      COMMIT;
      END IF;

      LOOP
          SELECT COUNT(*) INTO ROWCOUNT from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('BATCH_IDN_OATH2_AUTHRIZATN_CDE');
          IF (ROWCOUNT = 1) then
          EXECUTE IMMEDIATE 'DROP TABLE BATCH_IDN_OATH2_AUTHRIZATN_CDE';
          COMMIT;
          END if;

          EXECUTE IMMEDIATE 'CREATE TABLE BATCH_IDN_OATH2_AUTHRIZATN_CDE (ROW_ID rowid,CONSTRAINT BATCH_IDN_OATH_AUTHRIZN_PRI PRIMARY KEY (ROW_ID)) NOLOGGING';
          COMMIT;

          EXECUTE IMMEDIATE 'INSERT /*+ APPEND */ INTO BATCH_IDN_OATH2_AUTHRIZATN_CDE (ROW_ID) SELECT ROW_ID FROM CHNK_IDN_OATH_AUTHRIZATN_CODE WHERE rownum <= '||batchSize||'';
          batchCount:= sql%rowcount;
          COMMIT;

          EXIT WHEN batchCount = 0 ;

          IF (enableLog AND logLevel IN ('TRACE'))
          THEN
          EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BATCH DELETE START ON TABLE IDN_OAUTH2_AUTHORIZATION_CODE WITH : '||batchCount||''')';
          COMMIT;
          END IF;

          IF ((batchCount > 0))
          THEN
          EXECUTE IMMEDIATE 'DELETE FROM IDN_OAUTH2_AUTHORIZATION_CODE where rowid in (select ROW_ID from BATCH_IDN_OATH2_AUTHRIZATN_CDE)';
          deleteCount:= sql%rowcount;
          COMMIT;
          END IF;
          IF (enableLog)
          THEN
          EXECUTE IMMEDIATE  'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BATCH DELETE FINISHED ON IDN_OAUTH2_AUTHORIZATION_CODE WITH : '||deleteCount||''')';
          COMMIT;
          END IF;

          EXECUTE IMMEDIATE 'DELETE CHNK_IDN_OATH_AUTHRIZATN_CODE WHERE ROW_ID in (select ROW_ID from BATCH_IDN_OATH2_AUTHRIZATN_CDE)';
          COMMIT;
          IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
          THEN
          EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''DELETED BATCH ON  CHNK_IDN_OATH_AUTHRIZATN_CODE !'')';
          COMMIT;
          END IF;

          IF ((deleteCount > 0))
          THEN
          IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
          THEN
          EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''SLEEPING ...'')';
          COMMIT;
          END IF;
          --DBMS_LOCK.SLEEP(sleepTime);
          END IF;
      END LOOP;
END LOOP;

--
IF (enableLog)
THEN
  EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''BATCH DELETE ON IDN_OAUTH2_AUTHORIZATION_CODE COMPLETED .... !'')';
  EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
  COMMIT;
END IF;

IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
THEN
    SELECT COUNT(1) INTO ROWCOUNT FROM IDN_OAUTH2_ACCESS_TOKEN;
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL TOKENS ON IDN_OAUTH2_ACCESS_TOKEN TABLE AFTER DELETE :'||ROWCOUNT||''')';
    COMMIT;

    SELECT COUNT(1) INTO ROWCOUNT FROM IDN_OAUTH2_AUTHORIZATION_CODE;
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOTAL TOKENS ON IDN_OAUTH2_AUTHORIZATION_CODE TABLE AFTER DELETE :'||ROWCOUNT||''')';
    COMMIT;

    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
    COMMIT;
END IF;


-- ------------------------------------------------------
-- REBUILDING INDEXES
-- ------------------------------------------------------

IF(enableRebuildIndexes)
THEN
      FOR cursorTable IN backupTablesCursor
      LOOP
            FOR INDEX_ENTRY IN (SELECT INDEX_NAME FROM ALL_INDEXES WHERE  TABLE_NAME=''||cursorTable.TABLE_NAME||'' AND INDEX_TYPE='NORMAL' AND OWNER = CURRENT_SCHEMA)
            LOOP
                IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
                THEN
                EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''REBUILDING INDEXES ON '||cursorTable.TABLE_NAME||' TABLE : '||INDEX_ENTRY.INDEX_NAME||''')';
                COMMIT;
                END IF;
                EXECUTE IMMEDIATE 'ALTER INDEX ' || INDEX_ENTRY.INDEX_NAME || ' REBUILD';
                COMMIT;
            END LOOP;
      END LOOP;

      IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
      THEN
      EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
      END IF;
      COMMIT;
END IF;


-- ------------------------------------------------------
-- STATS GATHERING FOR OPTIMUM PERFOMANCE
-- ------------------------------------------------------

IF(enableStsGthrn)
THEN
    IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
    THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''SCHEMA LEVEL STATS GATHERING JOB STARTED.'')';
    COMMIT;
    END IF;

    BEGIN
    dbms_stats.gather_schema_stats(CURRENT_SCHEMA,DBMS_STATS.AUTO_SAMPLE_SIZE);
    END;

    IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
    THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''SCHEMA LEVEL STATS GATHERING JOB COMPLETED.'')';
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
    COMMIT;
    END IF;
END IF;

IF (enableLog AND logLevel IN ('DEBUG','TRACE'))
THEN
EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOKEN_CLEANUP_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''TOKEN_CLEANUP_SP COMPLETED .... !'')';
COMMIT;
END IF;

END;

/

CREATE OR REPLACE PROCEDURE WSO2_TOK_CLNUP_DT_RESTO_SP IS


rowCount INT;
CURRENT_SCHEMA VARCHAR(20);
-- ------------------------------------------
-- CONFIGURABLE ATTRIBUTES
-- ------------------------------------------
enableLog BOOLEAN := TRUE; -- ENABLE LOGGING [DEFAULT : TRUE]
logLevel VARCHAR(10):= 'TRACE'; -- SET LOG LEVELS : TRACE


BEGIN

SELECT SYS_CONTEXT( 'USERENV', 'CURRENT_SCHEMA' ) INTO CURRENT_SCHEMA FROM DUAL;



IF (enableLog)
THEN
    SELECT COUNT(*) INTO rowCount from ALL_TABLES where OWNER = CURRENT_SCHEMA AND table_name = upper('LOG_WSO2_TOK_CLN_DT_RESTR_SP');
    IF (rowCount = 1) then
    EXECUTE IMMEDIATE 'DROP TABLE LOG_WSO2_TOK_CLN_DT_RESTR_SP';
    COMMIT;
    END if;
    EXECUTE IMMEDIATE 'CREATE TABLE LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP VARCHAR(250) , LOG VARCHAR(250)) NOLOGGING';
    COMMIT;
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''WSO2_TOKEN_CLEANUP_DATA_RESTORATION_SP STARTED .... !'')';
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''USING SCHEMA :'||CURRENT_SCHEMA||''')';
    COMMIT;
END IF;


-- ---------------------

SELECT COUNT(1) INTO rowCount FROM ALL_TABLES where OWNER = CURRENT_SCHEMA AND TABLE_NAME IN ('IDN_OAUTH2_ACCESS_TOKEN');
IF (rowCount = 1)
THEN
    IF (enableLog AND logLevel IN ('TRACE')) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION STARTED ON IDN_OAUTH2_ACCESS_TOKEN TABLE !'')';
    COMMIT;
    END IF;
    EXECUTE IMMEDIATE 'INSERT INTO IDN_OAUTH2_ACCESS_TOKEN SELECT A.* FROM BAK_OAUTH2_ACCESS_TOKEN A LEFT JOIN IDN_OAUTH2_ACCESS_TOKEN B ON A.TOKEN_ID = B.TOKEN_ID WHERE B.TOKEN_ID IS NULL';
    rowCount:=  sql%Rowcount;
    IF (enableLog ) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION COMPLETED ON IDN_OAUTH2_ACCESS_TOKEN WITH '||rowCount||''')';
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
    COMMIT;
    END IF;
END IF;

-- ---------------------

SELECT COUNT(1) INTO rowCount FROM ALL_TABLES where OWNER = CURRENT_SCHEMA AND TABLE_NAME IN ('IDN_OAUTH2_AUTHORIZATION_CODE');
IF (rowCount = 1)
THEN
    IF (enableLog AND logLevel IN ('TRACE')) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION STARTED ON IDN_OAUTH2_AUTHORIZATION_CODE TABLE !'')';
    COMMIT;
    END IF;
    EXECUTE IMMEDIATE 'INSERT INTO IDN_OAUTH2_AUTHORIZATION_CODE SELECT A.* FROM BAK_OAUTH2_AUTHORIZATION_CODE A LEFT JOIN IDN_OAUTH2_AUTHORIZATION_CODE B ON A.CODE_ID = B.CODE_ID WHERE B.CODE_ID IS NULL';
    rowCount:=  sql%Rowcount;
    IF (enableLog ) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION COMPLETED ON IDN_OAUTH2_AUTHORIZATION_CODE WITH '||rowCount||''')';
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
    COMMIT;
    END IF;
END IF;

-- ---------------------

SELECT COUNT(1) INTO rowCount FROM ALL_TABLES where OWNER = CURRENT_SCHEMA AND TABLE_NAME IN ('IDN_OAUTH2_ACCESS_TOKEN_SCOPE');
IF (rowCount = 1)
THEN
    IF (enableLog AND logLevel IN ('TRACE')) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION STARTED ON IDN_OAUTH2_ACCESS_TOKEN_SCOPE TABLE !'')';
    COMMIT;
    END IF;
    EXECUTE IMMEDIATE 'INSERT INTO IDN_OAUTH2_ACCESS_TOKEN_SCOPE SELECT A.* FROM BAK_OAUTH2_ACCESS_TOKEN_SCOPE A LEFT JOIN IDN_OAUTH2_ACCESS_TOKEN_SCOPE B ON A.TOKEN_ID = B.TOKEN_ID AND A.TOKEN_SCOPE = B.TOKEN_SCOPE WHERE B.TOKEN_ID IS NULL';
    rowCount:=  sql%Rowcount;
    IF (enableLog ) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION COMPLETED ON IDN_OAUTH2_ACCESS_TOKEN_SCOPE WITH '||rowCount||''')';
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
    COMMIT;
    END IF;
END IF;

-- ---------------------

SELECT COUNT(1) INTO rowCount FROM ALL_TABLES where OWNER = CURRENT_SCHEMA AND TABLE_NAME IN ('IDN_OIDC_REQ_OBJECT_REFERENCE');
IF (rowCount = 1)
THEN
    IF (enableLog AND logLevel IN ('TRACE')) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION STARTED ON IDN_OIDC_REQ_OBJECT_REFERENCE TABLE !'')';
    COMMIT;
    END IF;
    EXECUTE IMMEDIATE 'INSERT INTO IDN_OIDC_REQ_OBJECT_REFERENCE SELECT A.* FROM BAK_OIDC_REQ_OBJECT_REFERENCE A LEFT JOIN IDN_OIDC_REQ_OBJECT_REFERENCE B ON A.ID = B.ID WHERE B.ID IS NULL';
    rowCount:=  sql%Rowcount;
    IF (enableLog ) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION COMPLETED ON IDN_OIDC_REQ_OBJECT_REFERENCE WITH '||rowCount||''')';
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
    COMMIT;
    END IF;
END IF;

-- --------------------

SELECT COUNT(1) INTO rowCount FROM ALL_TABLES where OWNER = CURRENT_SCHEMA AND TABLE_NAME IN ('IDN_OIDC_REQ_OBJECT_CLAIMS');
IF (rowCount = 1)
THEN
    IF (enableLog AND logLevel IN ('TRACE')) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION STARTED ON IDN_OIDC_REQ_OBJECT_CLAIMS TABLE !'')';
    COMMIT;
    END IF;
    EXECUTE IMMEDIATE 'INSERT INTO IDN_OIDC_REQ_OBJECT_CLAIMS SELECT A.* FROM BAK_OIDC_REQ_OBJECT_CLAIMS A LEFT JOIN IDN_OIDC_REQ_OBJECT_CLAIMS B ON A.ID = B.ID WHERE B.ID IS NULL';
    rowCount:=  sql%Rowcount;
    IF (enableLog ) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION COMPLETED ON IDN_OIDC_REQ_OBJECT_CLAIMS WITH '||rowCount||''')';
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
    COMMIT;
    END IF;
END IF;

-- -------------------

SELECT COUNT(1) INTO rowCount FROM ALL_TABLES where OWNER = CURRENT_SCHEMA AND TABLE_NAME IN ('IDN_OIDC_REQ_OBJ_CLAIM_VALUES');
IF (rowCount = 1)
THEN
    IF (enableLog AND logLevel IN ('TRACE')) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION STARTED ON IDN_OIDC_REQ_OBJ_CLAIM_VALUES TABLE !'')';
    COMMIT;
    END IF;
    EXECUTE IMMEDIATE 'INSERT INTO IDN_OIDC_REQ_OBJ_CLAIM_VALUES SELECT A.* FROM BAK_OIDC_REQ_OBJ_CLAIM_VALUES A LEFT JOIN IDN_OIDC_REQ_OBJ_CLAIM_VALUES B ON A.ID = B.ID WHERE B.ID IS NULL';
    rowCount:=  sql%Rowcount;
    IF (enableLog ) THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''CLEANUP DATA RESTORATION COMPLETED ON IDN_OIDC_REQ_OBJ_CLAIM_VALUES WITH '||rowcount||''')';
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),'' '')';
    COMMIT;
    END IF;
END IF;

IF (enableLog)
THEN
    EXECUTE IMMEDIATE 'INSERT INTO LOG_WSO2_TOK_CLN_DT_RESTR_SP (TIMESTAMP,LOG) VALUES (TO_CHAR( SYSTIMESTAMP, ''DD.MM.YYYY HH24:MI:SS:FF4''),''WSO2_TOKEN_CLEANUP_DATA_RESTORATION_SP COMPLETED .... !'')';
    COMMIT;
END IF;

END;


-- upgrade from 6.2 to 7.0------------------------------------------------------------------------------------------------------------------------------------------------
ALTER TABLE UM_ROLE add UM_ROLE_UUID VARCHAR2(255) DEFAULT SYS_GUID() NOT NULL;
ALTER TABLE UM_ROLE add UM_CREATED_TIME TIMESTAMP DEFAULT SYSDATE NOT NULL;
ALTER TABLE UM_ROLE add UM_LAST_MODIFIED TIMESTAMP DEFAULT SYSDATE NOT NULL;
ALTER TABLE UM_ROLE ADD CONSTRAINT U_UM_ROLE_UUID UNIQUE (UM_ROLE_UUID);
/
CREATE TABLE UM_HYBRID_ROLE_AUDIENCE(
            UM_ID INTEGER NOT NULL,
            UM_AUDIENCE VARCHAR(255) NOT NULL,
            UM_AUDIENCE_ID VARCHAR(255) NOT NULL,
            UNIQUE (UM_AUDIENCE, UM_AUDIENCE_ID),
            PRIMARY KEY (UM_ID)
)
ALTER TABLE UM_HYBRID_ROLE_AUDIENCE ADD UM_TENANT_ID INTEGER DEFAULT -1234;

INSERT INTO UM_HYBRID_ROLE_AUDIENCE (UM_AUDIENCE, UM_AUDIENCE_ID, UM_TENANT_ID) VALUES ('organization', SYS_GUID(), -1234);
INSERT INTO UM_HYBRID_ROLE_AUDIENCE (UM_AUDIENCE, UM_AUDIENCE_ID, UM_TENANT_ID) VALUES ('application', SYS_GUID(), -1234);
commit;

DECLARE
    v_counter NUMBER := 0;
BEGIN
    FOR rec IN (SELECT um_id FROM um_tenant) LOOP
     
      INSERT INTO UM_HYBRID_ROLE_AUDIENCE (UM_AUDIENCE, UM_AUDIENCE_ID, UM_TENANT_ID)
      values ('organization', SYS_GUID(), rec.um_id);
      INSERT INTO UM_HYBRID_ROLE_AUDIENCE (UM_AUDIENCE, UM_AUDIENCE_ID, UM_TENANT_ID)
      values ('application', SYS_GUID(), rec.um_id);
        
   END LOOP;
   commit;
END;

/
DECLARE
    v_tenant_id um_tenant.um_id%TYPE;
BEGIN
    FOR rec IN (select * from UM_HYBRID_ROLE_AUDIENCE where um_audience = 'application') LOOP
     
      INSERT INTO UM_HYBRID_ROLE (UM_ROLE_NAME, UM_TENANT_ID, UM_AUDIENCE_REF_ID, UM_UUID)
      values ('Administrator',rec.UM_TENANT_ID, rec.UM_ID, SYS_GUID());
     
   END LOOP;
   commit;
END;
/
update UM_HYBRID_ROLE  set UM_UUID = SYS_GUID(), UM_AUDIENCE_REF_ID = nvl((select um_id from UM_HYBRID_ROLE_AUDIENCE where um_hybrid_role.um_tenant_id = um_hybrid_role_audience.um_tenant_id and UM_AUDIENCE = 'organization'),-1)
    where um_role_name in ('admin','everyone','system');
	commit;

/
DECLARE
    v_tenant_id um_tenant.um_id%TYPE;
    v_domain_id number;
BEGIN
    FOR rec IN (select * from UM_HYBRID_ROLE_AUDIENCE where um_audience = 'application') LOOP
         select um_domain_id into v_domain_id from um_domain where um_tenant_id = rec.um_tenant_id and um_domain_name = 'PRIMARY';
        insert into UM_HYBRID_USER_ROLE  (um_user_name, um_role_id, um_tenant_id, um_domain_id)
        values('admin', rec.um_id, rec.um_tenant_id, v_domain_id);
   END LOOP;
   commit;
END;
/
CREATE SEQUENCE UM_HYBRID_ROLE_AUDIENCE_SEQUENCE START WITH 1 INCREMENT BY 1 NOCACHE;
/
CREATE OR REPLACE TRIGGER UM_HYBRID_ROLE_AUDIENCE_TRIGGER
                    BEFORE INSERT
                    ON UM_HYBRID_ROLE_AUDIENCE
                    REFERENCING NEW AS NEW
                    FOR EACH ROW
                    BEGIN
                    SELECT UM_HYBRID_ROLE_AUDIENCE_SEQUENCE.nextval INTO :NEW.UM_ID FROM dual;
              END;
/
ALTER TABLE UM_HYBRID_ROLE add UM_AUDIENCE_REF_ID INTEGER DEFAULT -1 NOT NULL;
ALTER TABLE UM_HYBRID_ROLE add UM_UUID VARCHAR(36);
--ALTER TABLE UM_HYBRID_ROLE MODIFY CONSTRAINT SYS_C0057376 UNIQUE (UM_ROLE_NAME, UM_TENANT_ID, UM_AUDIENCE_REF_ID);
CREATE TABLE UM_IDP_GROUP_ROLE(
            UM_ROLE_ID INTEGER NOT NULL,
            UM_GROUP_ID VARCHAR(36) NOT NULL,
            UM_TENANT_ID INTEGER NOT NULL,
            PRIMARY KEY (UM_ROLE_ID, UM_GROUP_ID, UM_TENANT_ID),
            FOREIGN KEY (UM_ROLE_ID, UM_TENANT_ID) REFERENCES UM_HYBRID_ROLE(UM_ID, UM_TENANT_ID) ON DELETE CASCADE
)
/
CREATE TABLE UM_SHARED_ROLE(
            UM_ID INTEGER NOT NULL,
            UM_SHARED_ROLE_ID INTEGER NOT NULL,
            UM_MAIN_ROLE_ID INTEGER NOT NULL,
            UM_SHARED_ROLE_TENANT_ID INTEGER NOT NULL,
            UM_MAIN_ROLE_TENANT_ID INTEGER NOT NULL,
            PRIMARY KEY (UM_ID),
            UNIQUE (UM_SHARED_ROLE_ID, UM_MAIN_ROLE_ID, UM_SHARED_ROLE_TENANT_ID),
            FOREIGN KEY (UM_SHARED_ROLE_ID, UM_SHARED_ROLE_TENANT_ID) REFERENCES UM_HYBRID_ROLE(UM_ID, UM_TENANT_ID) ON DELETE CASCADE,
            FOREIGN KEY (UM_MAIN_ROLE_ID, UM_MAIN_ROLE_TENANT_ID) REFERENCES UM_HYBRID_ROLE(UM_ID, UM_TENANT_ID) ON DELETE CASCADE
)
/
CREATE SEQUENCE UM_SHARED_ROLE_SEQUENCE START WITH 1 INCREMENT BY 1 NOCACHE;
/
CREATE OR REPLACE TRIGGER UM_SHARED_ROLE_TRIGGER
                    BEFORE INSERT
                    ON UM_SHARED_ROLE
                    REFERENCING NEW AS NEW
                    FOR EACH ROW
                    BEGIN
                    SELECT UM_SHARED_ROLE_SEQUENCE.nextval INTO :NEW.UM_ID FROM dual;
              END;
/
CREATE TABLE UM_ORG_DISCOVERY (
            UM_ID INTEGER,
            UM_ORG_ID VARCHAR(36) NOT NULL,
            UM_ROOT_ORG_ID VARCHAR(36) NOT NULL,
            UM_DISCOVERY_TYPE VARCHAR(255) NOT NULL,
            UM_DISCOVERY_VALUE VARCHAR(255) NOT NULL,
            PRIMARY KEY (UM_ID),
            UNIQUE (UM_ROOT_ORG_ID, UM_DISCOVERY_TYPE, UM_DISCOVERY_VALUE),
            FOREIGN KEY (UM_ROOT_ORG_ID) REFERENCES UM_ORG(UM_ID) ON DELETE CASCADE,
            FOREIGN KEY (UM_ORG_ID) REFERENCES UM_ORG(UM_ID) ON DELETE CASCADE
)
/
CREATE SEQUENCE UM_ORG_DISCOVERY_SEQ START WITH 1 INCREMENT BY 1 NOCACHE
/
CREATE OR REPLACE TRIGGER UM_ORG_DISCOVERY_TRIG
            BEFORE INSERT
            ON UM_ORG_DISCOVERY
            REFERENCING NEW AS NEW
            FOR EACH ROW
              BEGIN
                SELECT UM_ORG_DISCOVERY_SEQ.nextval INTO :NEW.UM_ID FROM dual;
              END;
/

CREATE TABLE UM_ORG_USER_ASSOCIATION(
    UM_USER_ID VARCHAR(255) NOT NULL,
    UM_ORG_ID VARCHAR(36) NOT NULL,
    UM_ASSOCIATED_USER_ID VARCHAR(255) NOT NULL,
    UM_ASSOCIATED_ORG_ID VARCHAR(36) NOT NULL,
    PRIMARY KEY (UM_USER_ID, UM_ORG_ID, UM_ASSOCIATED_USER_ID, UM_ASSOCIATED_ORG_ID)
)
/

-------IDENTITY-----------------------------
--ALTER TABLE IDN_OAUTH_CONSUMER_APPS MODIFY CONSTRAINT CONSUMER_KEY_CONSTRAINT UNIQUE (TENANT_ID, CONSUMER_KEY);
ALTER TABLE IDN_OAUTH2_ACCESS_TOKEN add AUTHORIZED_ORGANIZATION VARCHAR(36) DEFAULT 'NONE' NOT NULL;
-- CONSTRAINT CON_APP_KEY UNIQUE (CONSUMER_KEY_ID,AUTHZ_USER,TENANT_ID,USER_DOMAIN,USER_TYPE,TOKEN_SCOPE_HASH,TOKEN_STATE,TOKEN_STATE_ID,IDP_ID,TOKEN_BINDING_REF,AUTHORIZED_ORGANIZATION)
ALTER TABLE IDN_OAUTH2_DEVICE_FLOW add SUBJECT_IDENTIFIER VARCHAR(255);
/
CREATE TABLE IDN_RECOVERY_FLOW_DATA (
  RECOVERY_FLOW_ID VARCHAR2(255) NOT NULL,
  CODE VARCHAR2(255),
  FAILED_ATTEMPTS INTEGER DEFAULT 0 NOT NULL,
  RESEND_COUNT INTEGER DEFAULT 0 NOT NULL,
  TIME_CREATED TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  PRIMARY KEY(RECOVERY_FLOW_ID)
)
/

ALTER TABLE IDN_RECOVERY_DATA add RECOVERY_FLOW_ID VARCHAR2(255);
ALTER TABLE IDN_RECOVERY_DATA
ADD CONSTRAINT FK_IDN_RECOVERY_DATA_FLOW_ID
FOREIGN KEY (RECOVERY_FLOW_ID)
REFERENCES IDN_RECOVERY_FLOW_DATA(RECOVERY_FLOW_ID) ON DELETE CASCADE;
/
--FOREIGN KEY (TENANT_ID, CONSUMER_KEY) REFERENCES IDN_OAUTH_CONSUMER_APPS(TENANT_ID, CONSUMER_KEY) ON DELETE CASCADE)
--FOREIGN KEY (TENANT_ID, CONSUMER_KEY) REFERENCES IDN_OAUTH_CONSUMER_APPS(TENANT_ID, CONSUMER_KEY) ON DELETE CASCADE)
/
INSERT INTO IDN_CONFIG_TYPE (ID, NAME, DESCRIPTION) VALUES('8469a176-3e6c-438a-ba01-71e9077072fa', 'APPLICATION_BRANDING_PREFERENCES', 'A resource type to keep the application branding preferences');
INSERT INTO IDN_CONFIG_TYPE (ID, NAME, DESCRIPTION) VALUES('132b0ee6-43e0-462d-8b4b-15b68109d71d', 'ORGANIZATION_CONFIGURATION', 'A resource type to keep the organization configurations.');
INSERT INTO IDN_CONFIG_TYPE (ID, NAME, DESCRIPTION) VALUES('1fc809a0-dc0d-4cb2-82f3-58934d389236', 'CUSTOM_TEXT', 'A resource type to keep the tenant custom text preferences.');
/
--INSERT INTO IDN_SECRET_TYPE (ID, NAME, DESCRIPTION) VALUES ('433df096-62b7-4a36-b3eb-1bed9150ed35', 'IDVP_SECRET_PROPERTIES', 'Secret type to uniquely identify secrets relevant to identity verification providers');
INSERT INTO IDN_SECRET_TYPE (ID, NAME, DESCRIPTION) VALUES ('29d0c37d-139a-4b1e-a343-7b8d26f0a2a9', 'ANDROID_ATTESTATION_CREDENTIALS', 'Secret type to uniquely identify secrets relevant to android client attestation credentials');
commit;
select * from IDN_OAUTH_PAR;
ALTER TABLE IDN_OAUTH_PAR MODIFY CLIENT_ID VARCHAR2(255) NOT NULL;
ALTER TABLE IDN_OAUTH_PAR MODIFY SCHEDULED_EXPIRY NUMBER(22,0) NOT NULL;
/
CREATE TABLE IDN_ORG_USER_INVITATION (
	ID INTEGER NOT NULL,
	INVITATION_ID VARCHAR(40) NOT NULL,
	CONFIRMATION_CODE VARCHAR(40) NOT NULL,
	USER_NAME VARCHAR(255) NOT NULL,
	DOMAIN_NAME VARCHAR(255) NOT NULL,
	EMAIL VARCHAR(255) NOT NULL,
	USER_ORG_ID VARCHAR(255) NOT NULL,
	INVITED_ORG_ID VARCHAR(255) NOT NULL,
	USER_REDIRECT_URL VARCHAR(1024) NOT NULL,
	STATUS VARCHAR(10) NOT NULL,
	CREATED_AT TIMESTAMP NOT NULL,
	EXPIRED_AT TIMESTAMP NOT NULL,
	PRIMARY KEY (INVITATION_ID)
)
/
CREATE SEQUENCE IDN_ORG_USER_INVITATION_SEQ START WITH 1 INCREMENT BY 1 NOCACHE
/
CREATE OR REPLACE TRIGGER IDN_ORG_USER_INVITATION_TRIG
            BEFORE INSERT
            ON IDN_ORG_USER_INVITATION
            REFERENCING NEW AS NEW
            FOR EACH ROW
            BEGIN
                SELECT IDN_ORG_USER_INVITATION_SEQ.nextval INTO :NEW.ID FROM dual;
            END;
/
CREATE TABLE IDN_ORG_USER_INVITE_ASSIGNMENT (
	ID INTEGER NOT NULL,
	INVITATION_ID VARCHAR(40) NOT NULL,
  	ASSIGNMENT_ID VARCHAR(255) NOT NULL,
  	ASSIGNMENT_TYPE VARCHAR(255) NOT NULL,
  	PRIMARY KEY (INVITATION_ID, ASSIGNMENT_ID, ASSIGNMENT_TYPE),
	FOREIGN KEY (INVITATION_ID) REFERENCES IDN_ORG_USER_INVITATION(INVITATION_ID) ON DELETE CASCADE
)
/
CREATE SEQUENCE IDN_ORG_USER_INVITE_ASSIGNMENT_SEQ START WITH 1 INCREMENT BY 1 NOCACHE
/
CREATE OR REPLACE TRIGGER IDN_ORG_USER_INVITE_ASSIGNMENT_TRIG
            BEFORE INSERT
            ON IDN_ORG_USER_INVITE_ASSIGNMENT
            REFERENCING NEW AS NEW
            FOR EACH ROW
            BEGIN
                SELECT IDN_ORG_USER_INVITE_ASSIGNMENT_SEQ.nextval INTO :NEW.ID FROM dual;
            END;
/
CREATE TABLE API_RESOURCE (
  ID CHAR(36) NOT NULL PRIMARY KEY,
  CURSOR_KEY INTEGER NOT NULL,
  NAME VARCHAR(255) NOT NULL,
  IDENTIFIER VARCHAR(255) NOT NULL,
  TENANT_ID INT,
  DESCRIPTION VARCHAR(255),
  TYPE VARCHAR(255) NOT NULL,
  REQUIRES_AUTHORIZATION NUMBER(1,0) NOT NULL
)
/
CREATE SEQUENCE API_RESOURCE_SEQ START WITH 1 INCREMENT BY 1 NOCACHE
/
CREATE OR REPLACE TRIGGER API_RESOURCE_TRIG
  BEFORE INSERT
    ON API_RESOURCE
    REFERENCING NEW AS NEW
    FOR EACH ROW
  BEGIN
  SELECT API_RESOURCE_SEQ.nextval INTO :NEW.CURSOR_KEY FROM dual;
  END;
/
CREATE TABLE API_RESOURCE_PROPERTY (
  ID INTEGER,
  API_ID CHAR(36) NOT NULL,
  NAME VARCHAR(255) NOT NULL,
  VALUE VARCHAR(255) NOT NULL,
  PRIMARY KEY (ID),
  CONSTRAINT API_RESOURCE_PROPERTY_CONSTRAINT UNIQUE (API_ID, NAME),
  FOREIGN KEY (API_ID) REFERENCES API_RESOURCE(ID) ON DELETE CASCADE
)
/
CREATE SEQUENCE API_RESOURCE_PROPERTY_SEQ START WITH 1 INCREMENT BY 1 NOCACHE
/
CREATE OR REPLACE TRIGGER API_RESOURCE_PROPERTY_TRIG
  BEFORE INSERT
    ON API_RESOURCE_PROPERTY
    REFERENCING NEW AS NEW
    FOR EACH ROW
  BEGIN
  SELECT API_RESOURCE_PROPERTY_SEQ.nextval INTO :NEW.ID FROM dual;
  END;
/
CREATE TABLE SCOPE (
  ID CHAR(36) NOT NULL PRIMARY KEY,
  CURSOR_KEY INTEGER NOT NULL,
  API_ID CHAR(36) NOT NULL,
  NAME VARCHAR(255) NOT NULL,
  DISPLAY_NAME VARCHAR(255) NOT NULL,
  TENANT_ID INT,
  DESCRIPTION VARCHAR(300),
  FOREIGN KEY (API_ID) REFERENCES API_RESOURCE(ID) ON DELETE CASCADE
)
/
CREATE SEQUENCE SCOPE_SEQ START WITH 1 INCREMENT BY 1 NOCACHE
/
CREATE OR REPLACE TRIGGER SCOPE_TRIG
  BEFORE INSERT
    ON SCOPE
    REFERENCING NEW AS NEW
    FOR EACH ROW
  BEGIN
  SELECT SCOPE_SEQ.nextval INTO :NEW.CURSOR_KEY FROM dual;
  END;
/
CREATE TABLE APP_ROLE_ASSOCIATION (
  APP_ID CHAR(36) NOT NULL,
  ROLE_ID VARCHAR(255) NOT NULL,
  PRIMARY KEY (APP_ID, ROLE_ID),
  FOREIGN KEY (APP_ID) REFERENCES SP_APP(UUID) ON DELETE CASCADE
)
/
CREATE TABLE ROLE_SCOPE (
  ROLE_ID VARCHAR(255) NOT NULL,
  SCOPE_ID CHAR(36) NOT NULL,
  PRIMARY KEY (ROLE_ID, SCOPE_ID),
  FOREIGN KEY (SCOPE_ID) REFERENCES SCOPE(ID) ON DELETE CASCADE
)
/
CREATE TABLE AUTHORIZED_API (
  APP_ID CHAR(36) NOT NULL,
  API_ID CHAR(36) NOT NULL,
  POLICY_ID VARCHAR(255) NOT NULL,
  CONSTRAINT PK_APP_API PRIMARY KEY (APP_ID, API_ID),
  FOREIGN KEY (API_ID) REFERENCES API_RESOURCE(ID) ON DELETE CASCADE,
  FOREIGN KEY (APP_ID) REFERENCES SP_APP(UUID) ON DELETE CASCADE
)
/
CREATE TABLE AUTHORIZED_SCOPE (
  APP_ID CHAR(36) NOT NULL,
  API_ID CHAR(36) NOT NULL,
  SCOPE_ID CHAR(36) NOT NULL,
  CONSTRAINT PK_APP_API_SCOPE PRIMARY KEY (APP_ID, API_ID, SCOPE_ID),
  FOREIGN KEY (API_ID) REFERENCES API_RESOURCE(ID),
  FOREIGN KEY (SCOPE_ID) REFERENCES SCOPE(ID) ON DELETE CASCADE,
  FOREIGN KEY (APP_ID) REFERENCES SP_APP(UUID),
  FOREIGN KEY (APP_ID, API_ID) REFERENCES AUTHORIZED_API(APP_ID, API_ID) ON DELETE CASCADE,
  CONSTRAINT AUTHORIZED_SCOPE_UNIQUE UNIQUE (APP_ID, SCOPE_ID)
)
/
ALTER INDEX IDX_IOP_CK ON IDN_OIDC_PROPERTY(TENANT_ID, CONSUMER_KEY);
/
CREATE INDEX API_ID_NAME_INDEX ON SCOPE (API_ID, NAME);



